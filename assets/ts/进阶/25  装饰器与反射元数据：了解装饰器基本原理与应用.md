<div class="markdown-body"><p>上一节我们了解了 TypeScript 与 ECMAScript 的关系，以及可选链与空值合并这两个 TypeScript 中的 ECMAScript 提案。其实，还有一个 ECMAScript 提案也已经成为 TypeScript 中相当重要的一部分，它就是装饰器。</p>
<p>装饰器语法在 Python、Java 等语言中都能见到，但在 JavaScript 中并没有被大量使用。一方面是由于语法提案迟迟没有落地，装饰器甚至还不能被称为 JavaScript 的一部分，另一方面则是它对应用场景有着一定要求，比如只能使用在 Class 上，而 Class 并不是 JavaScript 中大量使用的语法。</p>
<p>在这一节，我们来介绍的是 TypeScript 中的装饰器，包括基础语法、不同种类的装饰器、反射、反射元数据等等，在了解完毕这些概念后，下一节我们就可以着手基于这些概念来实现依赖注入、IoC 容器等高阶玩法了。</p>
<p>另外需要注意的是，TypeScript 中的装饰器在 5.0 版本之前与之后是完全不同的两个概念，本小册介绍的所有装饰器内容均是基于 5.0 版本之前的装饰器。在新版装饰器提案（即 5.0 版本之后的装饰器）正式落地后，我们才会新增章节来进行解析。</p>
<blockquote>
<p>本节代码见：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Flinbudu599%2FTypeScript-Tiny-Book%2Ftree%2Fmain%2Fpackages%2F21-decorators" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/linbudu599/TypeScript-Tiny-Book/tree/main/packages/21-decorators" ref="nofollow noopener noreferrer">Decorators</a></p>
</blockquote>
<p>首先我们需要明确的是，<strong>装饰器的本质其实就是一个函数</strong>，只不过它的入参是提前确定好的。同时，TypeScript 中的装饰器目前同样<strong>只能在类以及类成员上使用</strong>。</p>
<p>装饰器通过 <code>@</code> 语法来使用：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Deco</span>(<span class="hljs-params"></span>) { }</span>
<span class="code-block-extension-codeLine" data-line-num="2"></span>
<span class="code-block-extension-codeLine" data-line-num="3"><span class="hljs-meta">@Deco</span></span>
<span class="code-block-extension-codeLine" data-line-num="4"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {}</span>
</code></pre>
<p>这样的装饰器只能起到固定的功能，因为它并不能动态接受入参。而我们实际上使用更多的是 Decorator Factory 的形式，即让 Deco 返回实际作为装饰器的函数，而不是本身作为装饰器。</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Deco</span>(<span class="hljs-params"></span>) { </span>
<span class="code-block-extension-codeLine" data-line-num="2">  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {}</span>
<span class="code-block-extension-codeLine" data-line-num="3">}</span>
<span class="code-block-extension-codeLine" data-line-num="4"></span>
<span class="code-block-extension-codeLine" data-line-num="5"><span class="hljs-meta">@Deco</span>()</span>
<span class="code-block-extension-codeLine" data-line-num="6"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {}</span>
</code></pre>
<p>在这种情况下，程序执行时会先执行 <code>Deco()</code> ，再用内部返回的函数作为装饰器的实际逻辑。这样，我们就可以通过入参来灵活地调整装饰器的作用。接下来，我们就来学习一下 TypeScript 中的装饰器是如何使用的，它们分别有什么作用？</p>
<h2 data-id="heading-0">装饰器大起底</h2>
<p>TypeScript 中的装饰器可以分为<strong>类装饰器</strong>、<strong>方法装饰器</strong>、<strong>访问符装饰器</strong>、<strong>属性装饰器</strong>以及<strong>参数装饰器</strong>五种，最常见的主要还是类装饰器、方法装饰器以及属性装饰器。接下来，我们会依次介绍这几种装饰器的具体使用。</p>
<h3 data-id="heading-1">类装饰器</h3>
<p>类装饰器是直接作用在类上的装饰器，它在执行时的入参只有一个，那就是这个类本身（而不是类的原型对象）。因此，我们可以通过类装饰器来覆盖类的属性与方法，如果你在类装饰器中返回一个新的类，它甚至可以篡改掉整个类的实现。</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-meta">@AddProperty</span>(<span class="hljs-string">'linbudu'</span>)</span>
<span class="code-block-extension-codeLine" data-line-num="2"><span class="hljs-meta">@AddMethod</span>()</span>
<span class="code-block-extension-codeLine" data-line-num="3"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="4">  a = <span class="hljs-number">1</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="5">}</span>
<span class="code-block-extension-codeLine" data-line-num="6"></span>
<span class="code-block-extension-codeLine" data-line-num="7"><span class="hljs-keyword">function</span> <span class="hljs-title function_">AddMethod</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">ClassDecorator</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="8">  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">target: <span class="hljs-built_in">any</span></span>) =&gt;</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="9">    target.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">newInstanceMethod</span> = <span class="hljs-function">() =&gt;</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="10">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Let's add a new instance method!"</span>);</span>
<span class="code-block-extension-codeLine" data-line-num="11">    };</span>
<span class="code-block-extension-codeLine" data-line-num="12">    target.<span class="hljs-property">newStaticMethod</span> = <span class="hljs-function">() =&gt;</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="13">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Let's add a new static method!"</span>);</span>
<span class="code-block-extension-codeLine" data-line-num="14">    };</span>
<span class="code-block-extension-codeLine" data-line-num="15">  };</span>
<span class="code-block-extension-codeLine" data-line-num="16">}</span>
<span class="code-block-extension-codeLine" data-line-num="17"></span>
<span class="code-block-extension-codeLine" data-line-num="18"><span class="hljs-keyword">function</span> <span class="hljs-title function_">AddProperty</span>(<span class="hljs-params">value: <span class="hljs-built_in">string</span></span>): <span class="hljs-title class_">ClassDecorator</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="19">  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">target: <span class="hljs-built_in">any</span></span>) =&gt;</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="20">    target.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">newInstanceProperty</span> = value;</span>
<span class="code-block-extension-codeLine" data-line-num="21">    target.<span class="hljs-property">newStaticProperty</span> = <span class="hljs-string">`static <span class="hljs-subst">${value}</span>`</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="22">  };</span>
<span class="code-block-extension-codeLine" data-line-num="23">}</span>
</code></pre>
<p>这里，我们通过 TypeScript 内置的 ClassDecorator 类型定义来进行类型标注，由于类装饰器只有一个参数，我们也不想使用过多的类型代码，这里我就直接 any 了。我们的函数返回了一个 ClassDecorator ，因此这个装饰器就是一个 Decorator Factory，在实际执行时需要以 <code>@Deco()</code> 的形式调用。</p>
<p>在 AddMethod 与 AddProperty 方法中，我们分别在 target、<code>target.prototype</code> 上添加了方法与属性，还记得 ES6 中 Class 的本质仍然是基于原型的吗？在这里 target 上的属性实际上是<strong>静态成员</strong>，也就是其实例上不会获得的方法，而 <code>target.prototype</code> 上的属性才是会随着继承与实例化过程被传递的<strong>实例成员</strong>。</p>
<p>我们来调用一下看看：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">const</span> <span class="hljs-attr">foo</span>: <span class="hljs-built_in">any</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>();</span>
<span class="code-block-extension-codeLine" data-line-num="2"></span>
<span class="code-block-extension-codeLine" data-line-num="3">foo.<span class="hljs-title function_">newInstanceMethod</span>();</span>
<span class="code-block-extension-codeLine" data-line-num="4">(&lt;<span class="hljs-built_in">any</span>&gt;<span class="hljs-title class_">Foo</span>).<span class="hljs-title function_">newStaticMethod</span>();</span>
<span class="code-block-extension-codeLine" data-line-num="5"></span>
<span class="code-block-extension-codeLine" data-line-num="6"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo.<span class="hljs-property">newInstanceProperty</span>);</span>
<span class="code-block-extension-codeLine" data-line-num="7"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((&lt;<span class="hljs-built_in">any</span>&gt;<span class="hljs-title class_">Foo</span>).<span class="hljs-property">newStaticProperty</span>);</span>
</code></pre>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">text</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-text code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1">Let's add a new instance method!</span>
<span class="code-block-extension-codeLine" data-line-num="2">Let's add a new static method!</span>
<span class="code-block-extension-codeLine" data-line-num="3">linbudu</span>
<span class="code-block-extension-codeLine" data-line-num="4">static linbudu</span>
</code></pre>
<p>我们在这里调用的方法并没有直接在 Foo 中定义，而是通过装饰器来强行添加！我们也可以在装饰中返回一个子类：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">const</span> <span class="hljs-title function_">OverrideBar</span> = (<span class="hljs-params">target: <span class="hljs-built_in">any</span></span>) =&gt; {</span>
<span class="code-block-extension-codeLine" data-line-num="2">  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> target {</span>
<span class="code-block-extension-codeLine" data-line-num="3">    <span class="hljs-title function_">print</span>(<span class="hljs-params"></span>) {}</span>
<span class="code-block-extension-codeLine" data-line-num="4">    <span class="hljs-title function_">overridedPrint</span>(<span class="hljs-params"></span>) {</span>
<span class="code-block-extension-codeLine" data-line-num="5">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'This is Overrided Bar!'</span>);</span>
<span class="code-block-extension-codeLine" data-line-num="6">    }</span>
<span class="code-block-extension-codeLine" data-line-num="7">  };</span>
<span class="code-block-extension-codeLine" data-line-num="8">};</span>
<span class="code-block-extension-codeLine" data-line-num="9"></span>
<span class="code-block-extension-codeLine" data-line-num="10"><span class="hljs-meta">@OverrideBar</span></span>
<span class="code-block-extension-codeLine" data-line-num="11"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="12">  <span class="hljs-title function_">print</span>(<span class="hljs-params"></span>) {</span>
<span class="code-block-extension-codeLine" data-line-num="13">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'This is Bar!'</span>);</span>
<span class="code-block-extension-codeLine" data-line-num="14">  }</span>
<span class="code-block-extension-codeLine" data-line-num="15">}</span>
<span class="code-block-extension-codeLine" data-line-num="16"></span>
<span class="code-block-extension-codeLine" data-line-num="17"><span class="hljs-comment">// 被覆盖了，现在是一个空方法</span></span>
<span class="code-block-extension-codeLine" data-line-num="18"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Bar</span>().<span class="hljs-title function_">print</span>();</span>
<span class="code-block-extension-codeLine" data-line-num="19"></span>
<span class="code-block-extension-codeLine" data-line-num="20"><span class="hljs-comment">// This is Overrided Bar!</span></span>
<span class="code-block-extension-codeLine" data-line-num="21">(&lt;<span class="hljs-built_in">any</span>&gt;<span class="hljs-keyword">new</span> <span class="hljs-title class_">Bar</span>()).<span class="hljs-title function_">overridedPrint</span>();</span>
</code></pre>
<p>在 React Class 组件时代，其实你会发现有许多功能也是通过装饰器实现的。如 Mobx 的 <code>@observer</code> 与 <code>@observable</code>，React-Redux 的 <code>@connect</code> 等。</p>
<h3 data-id="heading-2">方法装饰器</h3>
<p>方法装饰器的入参包括<strong>类的原型</strong>、<strong>方法名</strong>以及<strong>方法的属性描述符</strong>（PropertyDescriptor），而通过属性描述符你可以控制这个方法的内部实现（即 value）、可变性（即 writable）等信息。</p>
<p>能拿到原本实现，也就意味着，我们可以在执行原本方法的同时，插入一段新的逻辑，比如计算这个方法的执行耗时：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="2">  <span class="hljs-meta">@ComputeProfiler</span>()</span>
<span class="code-block-extension-codeLine" data-line-num="3">  <span class="hljs-keyword">async</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-params"></span>) {</span>
<span class="code-block-extension-codeLine" data-line-num="4">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="5">      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="6">        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'RES'</span>);</span>
<span class="code-block-extension-codeLine" data-line-num="7">      }, <span class="hljs-number">3000</span>);</span>
<span class="code-block-extension-codeLine" data-line-num="8">    });</span>
<span class="code-block-extension-codeLine" data-line-num="9">  }</span>
<span class="code-block-extension-codeLine" data-line-num="10">}</span>
<span class="code-block-extension-codeLine" data-line-num="11"></span>
<span class="code-block-extension-codeLine" data-line-num="12"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ComputeProfiler</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">MethodDecorator</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="13">  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params"></span></span></span>
<span class="code-block-extension-codeLine" data-line-num="14">    _target,</span>
<span class="code-block-extension-codeLine" data-line-num="15">    methodIdentifier,</span>
<span class="code-block-extension-codeLine" data-line-num="16">    descriptor: TypedPropertyDescriptor&lt;<span class="hljs-built_in">any</span>&gt;</span>
<span class="code-block-extension-codeLine" data-line-num="17">  ) =&gt; {</span>
<span class="code-block-extension-codeLine" data-line-num="18">    <span class="hljs-keyword">const</span> originalMethodImpl = descriptor.<span class="hljs-property">value</span>!;</span>
<span class="code-block-extension-codeLine" data-line-num="19">    descriptor.<span class="hljs-property">value</span> = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args: <span class="hljs-built_in">unknown</span>[]</span>) {</span>
<span class="code-block-extension-codeLine" data-line-num="20">      <span class="hljs-keyword">const</span> start = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();</span>
<span class="code-block-extension-codeLine" data-line-num="21">      <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> originalMethodImpl.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args); <span class="hljs-comment">// 执行原本的逻辑</span></span>
<span class="code-block-extension-codeLine" data-line-num="22">      <span class="hljs-keyword">const</span> end = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();</span>
<span class="code-block-extension-codeLine" data-line-num="23">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(</span>
<span class="code-block-extension-codeLine" data-line-num="24">        <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">String</span>(methodIdentifier)}</span> Time: `</span>,</span>
<span class="code-block-extension-codeLine" data-line-num="25">        end.<span class="hljs-title function_">getTime</span>() - start.<span class="hljs-title function_">getTime</span>()</span>
<span class="code-block-extension-codeLine" data-line-num="26">      );</span>
<span class="code-block-extension-codeLine" data-line-num="27">      <span class="hljs-keyword">return</span> res;</span>
<span class="code-block-extension-codeLine" data-line-num="28">    };</span>
<span class="code-block-extension-codeLine" data-line-num="29">  };</span>
<span class="code-block-extension-codeLine" data-line-num="30">}</span>
<span class="code-block-extension-codeLine" data-line-num="31"></span>
<span class="code-block-extension-codeLine" data-line-num="32">(<span class="hljs-keyword">async</span> () =&gt; {</span>
<span class="code-block-extension-codeLine" data-line-num="33">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>().<span class="hljs-title function_">fetch</span>());</span>
<span class="code-block-extension-codeLine" data-line-num="34">})();</span>
</code></pre>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">text</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-text code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1">fetch Time:  3003</span>
<span class="code-block-extension-codeLine" data-line-num="2">RES</span>
</code></pre>
<p>需要注意的是，方法装饰器的 target 是<strong>类的原型而非类本身</strong>。</p>
<h3 data-id="heading-3">访问符装饰器</h3>
<p>访问符装饰器并不常见，甚至访问符对于部分同学来说也是陌生的，但它其实就是 <code>get value(){}</code> 与 <code>set value(v)=&gt;{}</code> 这样的方法，其中 getter 在你访问这个属性 <code>value</code> 时触发，而 setter 在你对 <code>value</code> 进行赋值时触发。访问符装饰器本质上仍然是方法装饰器，它们使用的类型定义也相同。</p>
<p>需要注意的是，访问符装饰器只能同时应用在一对 getter / setter 的其中一个，即要么装饰 getter 要么装饰 setter 。这是因为，不论你是装饰哪一个，装饰器入参中的属性描述符都会包括 getter 与setter 方法：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="2">  _value!: <span class="hljs-built_in">string</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="3"></span>
<span class="code-block-extension-codeLine" data-line-num="4">  <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>() {</span>
<span class="code-block-extension-codeLine" data-line-num="5">    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="6">  }</span>
<span class="code-block-extension-codeLine" data-line-num="7"></span>
<span class="code-block-extension-codeLine" data-line-num="8">  <span class="hljs-meta">@HijackSetter</span>(<span class="hljs-string">'LIN_BU_DU'</span>)</span>
<span class="code-block-extension-codeLine" data-line-num="9">  <span class="hljs-keyword">set</span> <span class="hljs-title function_">value</span>(<span class="hljs-params">input: <span class="hljs-built_in">string</span></span>) {</span>
<span class="code-block-extension-codeLine" data-line-num="10">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> = input;</span>
<span class="code-block-extension-codeLine" data-line-num="11">  }</span>
<span class="code-block-extension-codeLine" data-line-num="12">}</span>
<span class="code-block-extension-codeLine" data-line-num="13"></span>
<span class="code-block-extension-codeLine" data-line-num="14"><span class="hljs-keyword">function</span> <span class="hljs-title function_">HijackSetter</span>(<span class="hljs-params">val: <span class="hljs-built_in">string</span></span>): <span class="hljs-title class_">MethodDecorator</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="15">  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">target, methodIdentifier, descriptor: <span class="hljs-built_in">any</span></span>) =&gt;</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="16">    <span class="hljs-keyword">const</span> originalSetter = descriptor.<span class="hljs-property">set</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="17">    descriptor.<span class="hljs-property">set</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">newValue: <span class="hljs-built_in">string</span></span>) {</span>
<span class="code-block-extension-codeLine" data-line-num="18">      <span class="hljs-keyword">const</span> composed = <span class="hljs-string">`Raw: <span class="hljs-subst">${newValue}</span>, Actual: <span class="hljs-subst">${val}</span>-<span class="hljs-subst">${newValue}</span>`</span></span>
<span class="code-block-extension-codeLine" data-line-num="19">      originalSetter.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, composed);</span>
<span class="code-block-extension-codeLine" data-line-num="20">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`HijackSetter: <span class="hljs-subst">${composed}</span>`</span>);</span>
<span class="code-block-extension-codeLine" data-line-num="21">    };</span>
<span class="code-block-extension-codeLine" data-line-num="22">    <span class="hljs-comment">// 篡改 getter，使得这个值无视 setter 的更新，返回一个固定的值</span></span>
<span class="code-block-extension-codeLine" data-line-num="23">    <span class="hljs-comment">// descriptor.get = function () {</span></span>
<span class="code-block-extension-codeLine" data-line-num="24">    <span class="hljs-comment">//   return val;</span></span>
<span class="code-block-extension-codeLine" data-line-num="25">    <span class="hljs-comment">// };</span></span>
<span class="code-block-extension-codeLine" data-line-num="26">  };</span>
<span class="code-block-extension-codeLine" data-line-num="27">}</span>
<span class="code-block-extension-codeLine" data-line-num="28"></span>
<span class="code-block-extension-codeLine" data-line-num="29"><span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>();</span>
<span class="code-block-extension-codeLine" data-line-num="30">foo.<span class="hljs-property">value</span> = <span class="hljs-string">'LINBUDU'</span>; <span class="hljs-comment">// HijackSetter: Raw: LINBUDU, Actual: LIN_BU_DU-LINBUDU</span></span>
</code></pre>
<p>在这个例子中，我们通过装饰器劫持了 setter ，在执行原本的 setter 方法修改了其参数。同时，我们也可以在这里去劫持 getter（<code>descriptor.get</code>），这样一来在读取这个值时，会直接返回一个我们固定好的值，而非其实际的值（如被 setter 更新过的）。</p>
<h3 data-id="heading-4">属性装饰器</h3>
<p>属性装饰器在独立使用时能力非常有限，它的入参只有<strong>类的原型</strong>与<strong>属性名称</strong>，返回值会被忽略，但你仍然可以通过<strong>直接在类的原型上赋值</strong>来修改属性：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="2">  <span class="hljs-meta">@ModifyNickName</span>()</span>
<span class="code-block-extension-codeLine" data-line-num="3">  nickName!: <span class="hljs-built_in">string</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="4">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {}</span>
<span class="code-block-extension-codeLine" data-line-num="5">}</span>
<span class="code-block-extension-codeLine" data-line-num="6"></span>
<span class="code-block-extension-codeLine" data-line-num="7"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ModifyNickName</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">PropertyDecorator</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="8">  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">target: <span class="hljs-built_in">any</span>, propertyIdentifier</span>) =&gt;</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="9">    target[propertyIdentifier] = <span class="hljs-string">'林不渡!'</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="10">    target[<span class="hljs-string">'otherName'</span>] = <span class="hljs-string">'别名林不渡!'</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="11">  };</span>
<span class="code-block-extension-codeLine" data-line-num="12">}</span>
<span class="code-block-extension-codeLine" data-line-num="13"></span>
<span class="code-block-extension-codeLine" data-line-num="14"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>().<span class="hljs-property">nickName</span>);</span>
<span class="code-block-extension-codeLine" data-line-num="15"><span class="hljs-comment">// @ts-expect-error</span></span>
<span class="code-block-extension-codeLine" data-line-num="16"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>().<span class="hljs-property">otherName</span>);</span>
</code></pre>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">text</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-text code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1">林不渡!</span>
<span class="code-block-extension-codeLine" data-line-num="2">别名林不渡!</span>
</code></pre>
<p>我们在原型对象上强行写入了属性，但这种方法实际上过于 hack，在后面我们会了解如何通过委托的方式来为一个属性注入值。</p>
<h3 data-id="heading-5">参数装饰器</h3>
<p>参数装饰器包括了构造函数的参数装饰器与方法的参数装饰器，它的入参包括<strong>类的原型</strong>、<strong>参数所在的方法名</strong>与<strong>参数在函数参数中的索引值（即第几个参数）</strong>，如果只是单独使用，它的作用同样非常有限。</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="2">  <span class="hljs-title function_">handler</span>(<span class="hljs-params"><span class="hljs-meta">@CheckParam</span>() input: <span class="hljs-built_in">string</span></span>) {</span>
<span class="code-block-extension-codeLine" data-line-num="3">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(input);</span>
<span class="code-block-extension-codeLine" data-line-num="4">  }</span>
<span class="code-block-extension-codeLine" data-line-num="5">}</span>
<span class="code-block-extension-codeLine" data-line-num="6"></span>
<span class="code-block-extension-codeLine" data-line-num="7"><span class="hljs-keyword">function</span> <span class="hljs-title function_">CheckParam</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">ParameterDecorator</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="8">  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">target, methodIdentifier, index</span>) =&gt;</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="9">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target, methodIdentifier, index);</span>
<span class="code-block-extension-codeLine" data-line-num="10">  };</span>
<span class="code-block-extension-codeLine" data-line-num="11">}</span>
<span class="code-block-extension-codeLine" data-line-num="12"></span>
<span class="code-block-extension-codeLine" data-line-num="13"><span class="hljs-comment">// {} handler 0</span></span>
<span class="code-block-extension-codeLine" data-line-num="14"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>().<span class="hljs-title function_">handler</span>(<span class="hljs-string">'linbudu'</span>);</span>
</code></pre>
<p>后面我们会了解如何基于参数装饰器进行参数的默认值注入与校验，现在就先到这儿，思考另一个问题：一个类中可以同时拥有这几种装饰器，那么这些<strong>不同装饰器的执行时机与顺序是如何的</strong>？</p>
<h3 data-id="heading-6">装饰器的执行机制</h3>
<p>装饰器的执行机制中主要包括<strong>执行时机</strong>、<strong>执行原理</strong>以及<strong>执行顺序</strong>这三个概念。</p>
<p>首先是执行时机，还记得我们在最开始说的吗？装饰器的本质就是一个函数，因此只要在类上定义了它，即使不去实例化这个类或者读取静态成员，它也会正常执行。很多时候，其实我们也并不会实例化具有装饰器的类，而是通过反射元数据的能力来消费，这一点我们后面会讲到。而装饰器的执行原理，我们可以通过编译后的代码来了解：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-meta">@Cls</span>()</span>
<span class="code-block-extension-codeLine" data-line-num="2"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="3">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-meta">@Param</span>() init?: <span class="hljs-built_in">string</span></span>) { }</span>
<span class="code-block-extension-codeLine" data-line-num="4"></span>
<span class="code-block-extension-codeLine" data-line-num="5">  <span class="hljs-meta">@Prop</span>()</span>
<span class="code-block-extension-codeLine" data-line-num="6">  prop!: <span class="hljs-built_in">string</span></span>
<span class="code-block-extension-codeLine" data-line-num="7"></span>
<span class="code-block-extension-codeLine" data-line-num="8">  <span class="hljs-meta">@Method</span>()</span>
<span class="code-block-extension-codeLine" data-line-num="9">  <span class="hljs-title function_">handler</span>(<span class="hljs-params"><span class="hljs-meta">@Param</span>() input: <span class="hljs-built_in">string</span></span>) {</span>
<span class="code-block-extension-codeLine" data-line-num="10"></span>
<span class="code-block-extension-codeLine" data-line-num="11">  }</span>
<span class="code-block-extension-codeLine" data-line-num="12">}</span>
</code></pre>
<p>这一段代码编译的产物会是这样的（经过简化）：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">javascript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-javascript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-meta">"use strict"</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="2"><span class="hljs-keyword">var</span> __decorate = (<span class="hljs-variable language_">this</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">__decorate</span>) || <span class="hljs-keyword">function</span> (<span class="hljs-params">decorators, target, key, desc</span>) {</span>
<span class="code-block-extension-codeLine" data-line-num="3">   <span class="hljs-comment">// ...</span></span>
<span class="code-block-extension-codeLine" data-line-num="4">};</span>
<span class="code-block-extension-codeLine" data-line-num="5"><span class="hljs-keyword">var</span> __param = (<span class="hljs-variable language_">this</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">__param</span>) || <span class="hljs-keyword">function</span> (<span class="hljs-params">paramIndex, decorator</span>) {</span>
<span class="code-block-extension-codeLine" data-line-num="6">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">target, key</span>) { <span class="hljs-title function_">decorator</span>(target, key, paramIndex); }</span>
<span class="code-block-extension-codeLine" data-line-num="7">};</span>
<span class="code-block-extension-codeLine" data-line-num="8"></span>
<span class="code-block-extension-codeLine" data-line-num="9"><span class="hljs-keyword">let</span> <span class="hljs-title class_">Foo</span> = <span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="10">    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">init</span>) { }</span>
<span class="code-block-extension-codeLine" data-line-num="11">    <span class="hljs-title function_">handler</span>(<span class="hljs-params">input</span>) {</span>
<span class="code-block-extension-codeLine" data-line-num="12">    }</span>
<span class="code-block-extension-codeLine" data-line-num="13">};</span>
<span class="code-block-extension-codeLine" data-line-num="14"><span class="hljs-title function_">__decorate</span>([</span>
<span class="code-block-extension-codeLine" data-line-num="15">    <span class="hljs-title class_">Prop</span>(),</span>
<span class="code-block-extension-codeLine" data-line-num="16">], <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">"prop"</span>, <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>);</span>
<span class="code-block-extension-codeLine" data-line-num="17"><span class="hljs-title function_">__decorate</span>([</span>
<span class="code-block-extension-codeLine" data-line-num="18">    <span class="hljs-title class_">Method</span>(),</span>
<span class="code-block-extension-codeLine" data-line-num="19">    <span class="hljs-title function_">__param</span>(<span class="hljs-number">0</span>, <span class="hljs-title class_">Param</span>()),</span>
<span class="code-block-extension-codeLine" data-line-num="20">], <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">"handler"</span>, <span class="hljs-literal">null</span>);</span>
<span class="code-block-extension-codeLine" data-line-num="21"><span class="hljs-title class_">Foo</span> = <span class="hljs-title function_">__decorate</span>([</span>
<span class="code-block-extension-codeLine" data-line-num="22">    <span class="hljs-title class_">Cls</span>(),</span>
<span class="code-block-extension-codeLine" data-line-num="23">    <span class="hljs-title function_">__param</span>(<span class="hljs-number">0</span>, <span class="hljs-title class_">Param</span>()),</span>
<span class="code-block-extension-codeLine" data-line-num="24">], <span class="hljs-title class_">Foo</span>);</span>
</code></pre>
<blockquote>
<p>完整的代码见：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.typescriptlang.org%2Fplay%3F%23code%2FGYVwdgxgLglg9mABAYQDYGcAUBKAXC1AQ3XQBEBTCOAJ0KhsQG8AoRRa8qEapTKQ6gHNO2RAF4AfE0QBfZnOahIsBIgCynABZwAJjnwao2nRSq161Jq3aduvfkJHipjWfOaLw0eEgAK1OAAHfUR-IPJqKABPUxo6BhY2Di4eRD4BYShRSSs2OQUlb1VfAUIAWxCS2jLOCNjzBOtkuzSHTOyXNwUAATQsbGYIIhJEADE4OFzEKjB0KGoQaBpMbqrynEQYMBgoAH58OeotwVFXBTZVgOCBtkCrg-nj8UQAclQtgCMQHRAXjwuwtdrHM6DAIIgQbAIICHkcwIJni9IWDEO8wF8fn9rN1DMYcNZNIQwDpUBEVmsKqItoEQFBYcdTv83Njcbp8WxkeDOQAJIkksmrUqUzZgGl0iGPeGM6z5DyDBBzRDACbPMDkADuYwmOAA3EA" target="_blank" rel="nofollow noopener noreferrer" title="https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABAYQDYGcAUBKAXC1AQ3XQBEBTCOAJ0KhsQG8AoRRa8qEapTKQ6gHNO2RAF4AfE0QBfZnOahIsBIgCynABZwAJjnwao2nRSq161Jq3aduvfkJHipjWfOaLw0eEgAK1OAAHfUR-IPJqKABPUxo6BhY2Di4eRD4BYShRSSs2OQUlb1VfAUIAWxCS2jLOCNjzBOtkuzSHTOyXNwUAATQsbGYIIhJEADE4OFzEKjB0KGoQaBpMbqrynEQYMBgoAH58OeotwVFXBTZVgOCBtkCrg-nj8UQAclQtgCMQHRAXjwuwtdrHM6DAIIgQbAIICHkcwIJni9IWDEO8wF8fn9rN1DMYcNZNIQwDpUBEVmsKqItoEQFBYcdTv83Njcbp8WxkeDOQAJIkksmrUqUzZgGl0iGPeGM6z5DyDBBzRDACbPMDkADuYwmOAA3EA" ref="nofollow noopener noreferrer">Playground</a></p>
</blockquote>
<p>这里的 <code>__decorate</code> 方法，其实就是通过实际入参来判断当前到底执行的是哪种装饰器，然后执行对应的装饰逻辑。而观察这个方法调用时的入参，我们会再次观察到这些装饰器的不同入参：<strong>方法与属性装饰器是类的原型对象</strong>，而<strong>类装饰器才能获得这个类本身作为入参</strong>。而属性装饰器应用时，这个属性还未被初始化（属性需要实例化才会有值），这也是为什么它无法像方法装饰器那样获取到值。</p>
<p>可以看到，上面的装饰器顺序依次是<strong>实例上的属性、方法、方法参数</strong>，然后是<strong>静态的属性、方法、方法参数</strong>，最后是<strong>类以及类构造函数参数</strong>。</p>
<p>而从这一编译结果中，我们还能观察到不同类型装饰器的<strong>执行顺序</strong>。首先是实例上的属性、方法、方法参数，然后是静态的属性、方法、方法参数，最后是类以及类构造函数参数。而装饰器的<strong>应用顺序</strong>则略有不同，<strong>方法参数装饰器会先于方法装饰器应用</strong>（<code>__param(0, Param())</code>）。</p>
<blockquote>
<p>关于执行顺序与应用顺序，执行是<strong>装饰器求值得到最终装饰器表达式</strong>的过程，而应用则是<strong>最终装饰器逻辑代码执行</strong>的过程：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deco</span>(<span class="hljs-params"></span>) {</span>
<span class="code-block-extension-codeLine" data-line-num="2">  <span class="hljs-comment">// 执行</span></span>
<span class="code-block-extension-codeLine" data-line-num="3">  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="4">    <span class="hljs-comment">// 应用</span></span>
<span class="code-block-extension-codeLine" data-line-num="5">  }</span>
<span class="code-block-extension-codeLine" data-line-num="6">}</span>
</code></pre>
</blockquote>
<p>实际上，对于实例与静态的属性、方法装饰器而言，它们的执行与应用顺序其实<strong>取决于它们定义的位置</strong>，你可以在上面的例子里把方法定义在属性之前，就会发现执行顺序变成了<strong>方法</strong>-<strong>方法参数</strong>-<strong>属性</strong>，即先定义先执行。</p>
<p>在 TypeScript 官方文档中对应用顺序给出了详细的定义：</p>
<ol>
<li><em>参数装饰器</em>，然后依次是<em>方法装饰器</em>，<em>访问符装饰器</em>，或<em>属性装饰器</em>应用到每个实例成员。</li>
<li><em>参数装饰器</em>，然后依次是<em>方法装饰器</em>，<em>访问符装饰器</em>，或<em>属性装饰器</em>应用到每个静态成员。</li>
<li><em>参数装饰器</em>应用到构造函数。</li>
<li><em>类装饰器</em>应用到类。</li>
</ol>
<p>最后，我们再看一个例子，来更深刻地了解执行顺序与应用顺序：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Deco</span>(<span class="hljs-params">identifier: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">any</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="2">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${identifier}</span> 执行`</span>);</span>
<span class="code-block-extension-codeLine" data-line-num="3">  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {</span>
<span class="code-block-extension-codeLine" data-line-num="4">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${identifier}</span> 应用`</span>);</span>
<span class="code-block-extension-codeLine" data-line-num="5">  };</span>
<span class="code-block-extension-codeLine" data-line-num="6">}</span>
<span class="code-block-extension-codeLine" data-line-num="7"></span>
<span class="code-block-extension-codeLine" data-line-num="8"><span class="hljs-meta">@Deco</span>(<span class="hljs-string">'类装饰器'</span>)</span>
<span class="code-block-extension-codeLine" data-line-num="9"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="10">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-meta">@Deco</span>(<span class="hljs-string">'构造函数参数装饰器'</span>) name: <span class="hljs-built_in">string</span></span>) {}</span>
<span class="code-block-extension-codeLine" data-line-num="11"></span>
<span class="code-block-extension-codeLine" data-line-num="12">  <span class="hljs-meta">@Deco</span>(<span class="hljs-string">'实例属性装饰器'</span>)</span>
<span class="code-block-extension-codeLine" data-line-num="13">  prop?: <span class="hljs-built_in">number</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="14"></span>
<span class="code-block-extension-codeLine" data-line-num="15">  <span class="hljs-meta">@Deco</span>(<span class="hljs-string">'实例方法装饰器'</span>)</span>
<span class="code-block-extension-codeLine" data-line-num="16">  <span class="hljs-title function_">handler</span>(<span class="hljs-params"><span class="hljs-meta">@Deco</span>(<span class="hljs-string">'实例方法参数装饰器'</span>) args: <span class="hljs-built_in">any</span></span>) {}</span>
<span class="code-block-extension-codeLine" data-line-num="17">}</span>
</code></pre>
<p>以上的代码输出是这样的：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">text</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-text code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1">实例属性装饰器 执行</span>
<span class="code-block-extension-codeLine" data-line-num="2">实例属性装饰器 应用</span>
<span class="code-block-extension-codeLine" data-line-num="3">实例方法装饰器 执行</span>
<span class="code-block-extension-codeLine" data-line-num="4">实例方法参数装饰器 执行</span>
<span class="code-block-extension-codeLine" data-line-num="5">实例方法参数装饰器 应用</span>
<span class="code-block-extension-codeLine" data-line-num="6">实例方法装饰器 应用</span>
<span class="code-block-extension-codeLine" data-line-num="7">类装饰器 执行</span>
<span class="code-block-extension-codeLine" data-line-num="8">构造函数参数装饰器 执行</span>
<span class="code-block-extension-codeLine" data-line-num="9">构造函数参数装饰器 应用</span>
<span class="code-block-extension-codeLine" data-line-num="10">类装饰器 应用</span>
</code></pre>
<p>执行顺序就不再赘述，这里我们主要关注应用顺序。顺序大致是<strong>实例属性-实例方法参数-构造函数参数-类</strong>，好像不对，不是说参数装饰器先应用吗？这是因为在这个例子中，我们是先定义属性和属性装饰器的，因此属性装饰器会先应用。如果方法在前，可不就是方法参数装饰器先应用？</p>
<p>你会发现，类装饰器是最后应用的。也就是说，如果我们在方法装饰器中标记某些信息，最终的类装饰器是可以消费到，并且基于此信息对类或类的实例进行某些操作的。如标记为 <code>@Deprecated</code> 的方法，我们在最终的类装饰器中可以将这些方法实现替换为一个报错！而标记这些信息的方法则有很多，最简单的如，在全局声明一个 Map，类作为 Key，这些信息作为 Value 也是可以的。当然，后面我们会说到如何使用更好的方式实现。</p>
<h4 data-id="heading-7">多个同类装饰器的执行顺序</h4>
<p>另外，我们也可以使用多个同种装饰器，比如一个类上可以有好多个类装饰器：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-meta">@Deprecated</span>()</span>
<span class="code-block-extension-codeLine" data-line-num="2"><span class="hljs-meta">@User</span>()</span>
<span class="code-block-extension-codeLine" data-line-num="3"><span class="hljs-meta">@Internal</span></span>
<span class="code-block-extension-codeLine" data-line-num="4"><span class="hljs-meta">@Provide</span>()</span>
<span class="code-block-extension-codeLine" data-line-num="5"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {}</span>
</code></pre>
<p>这种情况下，这些装饰器的执行顺序又是怎样的？其顺序分为两步。首先，<strong>由上至下</strong>依次对装饰器的表达式求值，得到装饰器的实现，<code>@Internal</code> 中实现即为 Internal 方法，而 <code>@Provide()</code> 中实现则需要进行一次求值。</p>
<p>然后，这些装饰器的具体实现才会<strong>从下往上</strong>调用，如这里是 Provide、Internal、User、Deprecated 的顺序。从这个角度来看，甚至有点像洋葱模型：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">MethodDecorator</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="2">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'foo in'</span>);</span>
<span class="code-block-extension-codeLine" data-line-num="3">  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">target, propertyKey, descriptor</span>) =&gt;</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="4">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'foo out'</span>);</span>
<span class="code-block-extension-codeLine" data-line-num="5">  };</span>
<span class="code-block-extension-codeLine" data-line-num="6">}</span>
<span class="code-block-extension-codeLine" data-line-num="7"></span>
<span class="code-block-extension-codeLine" data-line-num="8"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Bar</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">MethodDecorator</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="9">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'bar in'</span>);</span>
<span class="code-block-extension-codeLine" data-line-num="10">  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">target, propertyKey, descriptor</span>) =&gt;</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="11">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'bar out'</span>);</span>
<span class="code-block-extension-codeLine" data-line-num="12">  };</span>
<span class="code-block-extension-codeLine" data-line-num="13">}</span>
<span class="code-block-extension-codeLine" data-line-num="14"></span>
<span class="code-block-extension-codeLine" data-line-num="15"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Baz</span>: <span class="hljs-title class_">MethodDecorator</span> = <span class="hljs-function">() =&gt;</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="16">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'baz apply'</span>);</span>
<span class="code-block-extension-codeLine" data-line-num="17">};</span>
<span class="code-block-extension-codeLine" data-line-num="18"></span>
<span class="code-block-extension-codeLine" data-line-num="19"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="20">  <span class="hljs-meta">@Foo</span>()</span>
<span class="code-block-extension-codeLine" data-line-num="21">  <span class="hljs-meta">@Bar</span>()</span>
<span class="code-block-extension-codeLine" data-line-num="22">  <span class="hljs-meta">@Baz</span></span>
<span class="code-block-extension-codeLine" data-line-num="23">  <span class="hljs-title function_">method</span>(<span class="hljs-params"></span>) {}</span>
<span class="code-block-extension-codeLine" data-line-num="24">}</span>
<span class="code-block-extension-codeLine" data-line-num="25"></span>
<span class="code-block-extension-codeLine" data-line-num="26"><span class="hljs-comment">// foo in</span></span>
<span class="code-block-extension-codeLine" data-line-num="27"><span class="hljs-comment">// bar in</span></span>
<span class="code-block-extension-codeLine" data-line-num="28"><span class="hljs-comment">// baz apply</span></span>
<span class="code-block-extension-codeLine" data-line-num="29"><span class="hljs-comment">// bar out</span></span>
<span class="code-block-extension-codeLine" data-line-num="30"><span class="hljs-comment">// foo out</span></span>
</code></pre>
<p>类似的，如果一个方法中的多个参数均存在装饰器，那么同样是 <code>Parma1 in</code> - <code>Param2 in </code> - <code>Param2 out</code> - <code>Param1 out</code> 的顺序，也就是<strong>后面参数的装饰器逻辑</strong>反而先执行。</p>
<p><strong>但我们通常不会在同种装饰器中进行存在依赖关系的操作。</strong> 对于属性、参数装饰器来说，我们通常只进行信息注册，委托别人处理。对于方法装饰器来说，我们最多只进行方法执行前后的逻辑注入。而这些过程都应当是彼此独立的。</p>
<p>那么，这里的委托又如何实现呢？这时候我们就要介绍一位新朋友了：<strong>反射（Reflect）</strong>。你可能很早就认识，但没怎么接触过。</p>
<h2 data-id="heading-8">反射 Reflect</h2>
<p>Reflect 是在 ES6 中引入的全局对象，它仅仅是用于作为一个命名空间来存放顶级方法，比如 <code>Reflect.ownKeys</code>、<code>Reflect.defineProperty</code> 等等。你可能会感到疑惑，不是已经有了个 <code>Object.defineProperty</code> 吗？</p>
<p>这就是引入 Reflect 的目的之一了，我们知道 JavaScript 的早期有相当多比较“赶工”的部分，比如 <code>Object.defineProperty</code> 其实不应该放在 Object 命名空间下，它其实是整个语言层面的顶级方法，比如我们并不是只能用它来给对象定义属性：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {}</span>
<span class="code-block-extension-codeLine" data-line-num="2"></span>
<span class="code-block-extension-codeLine" data-line-num="3"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(foo, <span class="hljs-string">'validator'</span>, {</span>
<span class="code-block-extension-codeLine" data-line-num="4">  <span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {</span>
<span class="code-block-extension-codeLine" data-line-num="5">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Validation Failed'</span>);</span>
<span class="code-block-extension-codeLine" data-line-num="6">  },</span>
<span class="code-block-extension-codeLine" data-line-num="7">});</span>
<span class="code-block-extension-codeLine" data-line-num="8"></span>
<span class="code-block-extension-codeLine" data-line-num="9">foo.<span class="hljs-title function_">validator</span>();</span>
</code></pre>
<p>在上面的例子里，我们就使用 <code>Object.defineProperty</code> 给函数 foo 定义了一个属性方法 validator，那这不就显得怪怪的了，怎么用对象下的顶级方法来处理函数了？</p>
<p>在引入 Reflect 后，后续再有这一类语言层面的顶级方法，就可以把它放置在 Reflect 命名空间下了。另外，此前某些 Object 下的顶级方法可能存在一些不合理的行为，比如 <code>Object.defineProperty</code> 用于为一个不可扩展的对象定义属性时，会抛出一个错误，这种语言的历史债务已经无法再修改，那么，正好我们现在在 Reflect 下也提供了一个同名实现，就可以趁此机会把这些方法的表现修改得更合理一些。</p>
<p>除此以外，Reflect 还有一个比较特殊的作用场景是配合 Proxy。比如下面的例子里，我们通过 Proxy 修改了 target 对象的赋值行为 set，那假设我们只是想在赋值行为前后做点事情，还是想进行赋值操作的，此时应该咋办？假如你这么写：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">js</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-js code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">const</span> target = {};</span>
<span class="code-block-extension-codeLine" data-line-num="2"></span>
<span class="code-block-extension-codeLine" data-line-num="3"><span class="hljs-keyword">const</span> proxiedTarget = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, {</span>
<span class="code-block-extension-codeLine" data-line-num="4">  <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">target, name, value, receiver</span>) {</span>
<span class="code-block-extension-codeLine" data-line-num="5">    proxiedTarget.<span class="hljs-property">name</span> = value;</span>
<span class="code-block-extension-codeLine" data-line-num="6">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'property '</span> + name + <span class="hljs-string">' set to '</span> + value);</span>
<span class="code-block-extension-codeLine" data-line-num="7">  },</span>
<span class="code-block-extension-codeLine" data-line-num="8">});</span>
<span class="code-block-extension-codeLine" data-line-num="9"></span>
<span class="code-block-extension-codeLine" data-line-num="10">proxiedTarget.<span class="hljs-property">name</span> = <span class="hljs-string">'foo'</span>;</span>
</code></pre>
<p>执行这段代码，恭喜你得到了一个 <code>Maximum call stack size exceeded</code> 错误。这是因为此时 proxiedTarget 的 set 方法已经被代理了，在 set 方法内去赋值又会再进入 set 方法...。</p>
<p>此时，我们需要使用 <code>Reflect.set</code> 方法来实现赋值逻辑：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">const</span> target = {};</span>
<span class="code-block-extension-codeLine" data-line-num="2"></span>
<span class="code-block-extension-codeLine" data-line-num="3"><span class="hljs-keyword">const</span> proxiedTarget = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, {</span>
<span class="code-block-extension-codeLine" data-line-num="4">  <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">target, name, value, receiver</span>) {</span>
<span class="code-block-extension-codeLine" data-line-num="5">    <span class="hljs-keyword">const</span> success = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, name, value, receiver);</span>
<span class="code-block-extension-codeLine" data-line-num="6">    <span class="hljs-keyword">if</span> (success) {</span>
<span class="code-block-extension-codeLine" data-line-num="7">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'property '</span> + name + <span class="hljs-string">' set to '</span> + value);</span>
<span class="code-block-extension-codeLine" data-line-num="8">    }</span>
<span class="code-block-extension-codeLine" data-line-num="9">    <span class="hljs-keyword">return</span> success;</span>
<span class="code-block-extension-codeLine" data-line-num="10">  },</span>
<span class="code-block-extension-codeLine" data-line-num="11">});</span>
<span class="code-block-extension-codeLine" data-line-num="12"></span>
<span class="code-block-extension-codeLine" data-line-num="13">proxiedTarget.<span class="hljs-property">name</span> = <span class="hljs-string">'foo'</span>;</span>
</code></pre>
<p>这样就行了！Proxy 上的这些方法会一一对应到 Reflect 中，如 defineProperty、deleteProperty、apply、get、set、has 等等，这样一来，无论你在 Proxy 中覆盖了哪个方法，都可以使用 Reflect 来获取到其原本的实现。</p>
<p>总结一下，Reflect 方法主要有这么些功能：</p>
<ul>
<li>整理语言层面的顶级方法，让它们待在更合理的命名空间下。</li>
<li>修正部分方法的表现。</li>
<li>配合 Proxy，提供一份不会被覆盖的方法实现。</li>
</ul>
<p>在上面例子里， <code>Reflect.set</code> 方法是运行时才实际执行的，也就是说我们通过反射，在<strong>运行时去修改了程序的行为</strong>。这就是反射的核心要素：<strong>在程序运行时去检查、修改程序行为</strong>，比如除了赋值以外，我们还可以在运行时通过 <code>Reflect.construct</code> 实例化一个类，通过 <code>Reflect.setPrototypeOf</code> 修改对象原型指向等等。</p>
<p>虽然我们的主要内容和反射并没有太大的关系，下面要介绍的反射元数据才是本节的重量级角色，但是，了解「运行时修改程序行为」这个关键，能够帮助你更好地理解反射元数据的概念。</p>
<h2 data-id="heading-9">反射元数据 Reflect Metadata</h2>
<p>不同于反射，<strong>反射元数据（Reflect Metadata）</strong> 这一提案虽然同样很早就被提出，但至今都未真正的成为 ECMAScript 的一部分，原因在于，元数据和装饰器提案的联系非常紧密，随着装饰器提案迟迟不能推进，元数据当然也无法独自向前。目前，想要使用反射元数据，你还需要安装 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Frbuckton%2Freflect-metadata" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/rbuckton/reflect-metadata" ref="nofollow noopener noreferrer">reflect-metadata</a> ，并在入口文件中的顶部 <code>import "reflect-metadata"</code> 。</p>
<p>反射元数据提案（即 <code>"reflect-metadata"</code> 包）为 Reflect 新增了一批专用于元数据读写的 API，如 <code>Reflect.defineMetadata</code>、<code>Reflect.getMetadata</code> 等。</p>
<p>那么，元数据又是什么？想想我们在上面介绍的反射的概念——「在程序运行时修改程序行为」，在想想「反射元数据」这个名词，会不会有点灵感？</p>
<p>你可以将元数据理解为，<strong>用于描述程序自身特性的数据</strong>，比如，某个方法的参数信息、返回值信息可以称为该方法的元数据，某个类的实例化参数、内部的方法可以称之为这个类的元数据。</p>
<p>因此我们可以知道，Reflect 中新增的元数据读写方法，其实也还是用于运行时的各种操作。先来简单使用下元数据的注册与提取：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">import</span> <span class="hljs-string">'reflect-metadata'</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="2"></span>
<span class="code-block-extension-codeLine" data-line-num="3"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="4">  <span class="hljs-title function_">handler</span>(<span class="hljs-params"></span>) {}</span>
<span class="code-block-extension-codeLine" data-line-num="5">}</span>
<span class="code-block-extension-codeLine" data-line-num="6"></span>
<span class="code-block-extension-codeLine" data-line-num="7"><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineMetadata</span>(<span class="hljs-string">'class:key'</span>, <span class="hljs-string">'class metadata'</span>, <span class="hljs-title class_">Foo</span>);</span>
<span class="code-block-extension-codeLine" data-line-num="8"><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineMetadata</span>(<span class="hljs-string">'method:key'</span>, <span class="hljs-string">'handler metadata'</span>, <span class="hljs-title class_">Foo</span>, <span class="hljs-string">'handler'</span>);</span>
<span class="code-block-extension-codeLine" data-line-num="9"><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineMetadata</span>(</span>
<span class="code-block-extension-codeLine" data-line-num="10">  <span class="hljs-string">'proto:method:key'</span>,</span>
<span class="code-block-extension-codeLine" data-line-num="11">  <span class="hljs-string">'proto handler metadata'</span>,</span>
<span class="code-block-extension-codeLine" data-line-num="12">  <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,</span>
<span class="code-block-extension-codeLine" data-line-num="13">  <span class="hljs-string">'handler'</span></span>
<span class="code-block-extension-codeLine" data-line-num="14">);</span>
</code></pre>
<p>defineMetadata 的入参包括元数据 Key、元数据 Value、目标类 Target 以及一个可选的属性，上面的三处调用分别代表了：</p>
<ul>
<li>在 Foo 这个类上，注册一个 key 为 class:key，值为 class metadata 的元数据</li>
<li>在 Foo 这个类的方法 handler 上，注册一个 key 为 method:key，值为 handler metadata 的元数据</li>
<li>在 Foo 这个类的原型的方法 handler 上，注册一个 key 为 proto:method:key，值为 proto handler metadata 的元数据</li>
</ul>
<p>而提取则可以通过 getMetadata 方法：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-comment">// class metadata</span></span>
<span class="code-block-extension-codeLine" data-line-num="2"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadata</span>(<span class="hljs-string">'class:key'</span>, <span class="hljs-title class_">Foo</span>));</span>
<span class="code-block-extension-codeLine" data-line-num="3"><span class="hljs-comment">// handler metadata</span></span>
<span class="code-block-extension-codeLine" data-line-num="4"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadata</span>(<span class="hljs-string">'method:key'</span>, <span class="hljs-title class_">Foo</span>, <span class="hljs-string">'handler'</span>));</span>
<span class="code-block-extension-codeLine" data-line-num="5"><span class="hljs-comment">// proto handler metadata</span></span>
<span class="code-block-extension-codeLine" data-line-num="6"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadata</span>(<span class="hljs-string">'proto:method:key'</span>, <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">'handler'</span>));</span>
</code></pre>
<p>实际上，反射元数据正是我们实现属性装饰器中提到的“委托”能力的基础。现在我们可以使用元数据进一步完善它了：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">import</span> <span class="hljs-string">'reflect-metadata'</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="2"></span>
<span class="code-block-extension-codeLine" data-line-num="3"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="4"></span>
<span class="code-block-extension-codeLine" data-line-num="5">  <span class="hljs-meta">@ModifyNickName</span>()</span>
<span class="code-block-extension-codeLine" data-line-num="6">  nickName!: <span class="hljs-built_in">string</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="7">  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {}</span>
<span class="code-block-extension-codeLine" data-line-num="8">}</span>
<span class="code-block-extension-codeLine" data-line-num="9"></span>
<span class="code-block-extension-codeLine" data-line-num="10"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ModifyNickName</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">PropertyDecorator</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="11">  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">target: <span class="hljs-built_in">any</span>, propertyIdentifier</span>) =&gt;</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="12">    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineMetadata</span>(<span class="hljs-string">'prop'</span>, propertyIdentifier, target)</span>
<span class="code-block-extension-codeLine" data-line-num="13">  };</span>
<span class="code-block-extension-codeLine" data-line-num="14">}</span>
<span class="code-block-extension-codeLine" data-line-num="15"></span>
<span class="code-block-extension-codeLine" data-line-num="16"><span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>();</span>
<span class="code-block-extension-codeLine" data-line-num="17"></span>
<span class="code-block-extension-codeLine" data-line-num="18"><span class="hljs-keyword">const</span> propToInject = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadata</span>(<span class="hljs-string">'prop'</span>, foo);</span>
<span class="code-block-extension-codeLine" data-line-num="19"></span>
<span class="code-block-extension-codeLine" data-line-num="20"><span class="hljs-keyword">const</span> propProvider = {</span>
<span class="code-block-extension-codeLine" data-line-num="21">  <span class="hljs-attr">nickName</span>: <span class="hljs-string">'林不渡'</span>,</span>
<span class="code-block-extension-codeLine" data-line-num="22">  <span class="hljs-attr">otherName</span>: <span class="hljs-string">'别名林不渡'</span></span>
<span class="code-block-extension-codeLine" data-line-num="23">}</span>
<span class="code-block-extension-codeLine" data-line-num="24"></span>
<span class="code-block-extension-codeLine" data-line-num="25">foo[propToInject] = propProvider[propToInject];</span>
<span class="code-block-extension-codeLine" data-line-num="26"></span>
<span class="code-block-extension-codeLine" data-line-num="27"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo); <span class="hljs-comment">// { nickName: '林不渡' }</span></span>
</code></pre>
<p>来解释一下上面的代码：</p>
<ul>
<li>在属性装饰器中 <code>ModifyNickName</code> ，为这个类注册一个元数据，名为 prop，值为 nickName 属性名。也就是告知后续调用方，这个类型上的 nickName 属性名需要被修改。</li>
<li>在实例化这个类后，拿到实例上的元数据，获得 nickName 这个属性名。</li>
<li>从 propProvider 中，将 nickName 这个属性名对应的值取出，赋值给实例 foo 上的同名属性。</li>
</ul>
<p>相比于开始的简单粗暴的注入方式，使用元数据实现的委托要更加标准与灵活。我们只需要实现一个 propProvider 这样的集中式注入中心，再按照需要注入元数据，就能够完成各种基于元数据的修改行为了。</p>
<p>而实际上，某些时候我们使用装饰器就仅仅只是为了注入元数据而已。考虑到这一点，反射元数据中直接就内置了基于装饰器的调用方式：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-meta">@Reflect</span>.<span class="hljs-title function_">metadata</span>(<span class="hljs-string">'class:key'</span>, <span class="hljs-string">'METADATA_IN_CLASS'</span>)</span>
<span class="code-block-extension-codeLine" data-line-num="2"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="3">  <span class="hljs-meta">@Reflect</span>.<span class="hljs-title function_">metadata</span>(<span class="hljs-string">'prop:key'</span>, <span class="hljs-string">'METADATA_IN_PROPERTY'</span>)</span>
<span class="code-block-extension-codeLine" data-line-num="4">  <span class="hljs-keyword">public</span> <span class="hljs-attr">prop</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">'linbudu'</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="5"></span>
<span class="code-block-extension-codeLine" data-line-num="6">  <span class="hljs-meta">@Reflect</span>.<span class="hljs-title function_">metadata</span>(<span class="hljs-string">'method:key'</span>, <span class="hljs-string">'METADATA_IN_METHOD'</span>)</span>
<span class="code-block-extension-codeLine" data-line-num="7">  <span class="hljs-keyword">public</span> <span class="hljs-title function_">handler</span>(): <span class="hljs-built_in">void</span> {}</span>
<span class="code-block-extension-codeLine" data-line-num="8">}</span>
</code></pre>
<p><code>@Reflect.metadata</code> 装饰器会基于应用的位置进行实际的逻辑调用，如在类上装饰时以类作为 target 进行注册，而在静态成员与实例成员中分别使用构造函数、构造函数原型。</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>();</span>
<span class="code-block-extension-codeLine" data-line-num="2"></span>
<span class="code-block-extension-codeLine" data-line-num="3"><span class="hljs-comment">// METADATA_IN_CLASS</span></span>
<span class="code-block-extension-codeLine" data-line-num="4"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadata</span>(<span class="hljs-string">'class:key'</span>, <span class="hljs-title class_">Foo</span>));</span>
<span class="code-block-extension-codeLine" data-line-num="5"><span class="hljs-comment">// undefined</span></span>
<span class="code-block-extension-codeLine" data-line-num="6"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadata</span>(<span class="hljs-string">'class:key'</span>, <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>));</span>
<span class="code-block-extension-codeLine" data-line-num="7"></span>
<span class="code-block-extension-codeLine" data-line-num="8"><span class="hljs-comment">// METADATA_IN_METHOD</span></span>
<span class="code-block-extension-codeLine" data-line-num="9"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadata</span>(<span class="hljs-string">'method:key'</span>, <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">'handler'</span>));</span>
<span class="code-block-extension-codeLine" data-line-num="10"><span class="hljs-comment">// METADATA_IN_METHOD</span></span>
<span class="code-block-extension-codeLine" data-line-num="11"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadata</span>(<span class="hljs-string">'method:key'</span>, foo, <span class="hljs-string">'handler'</span>));</span>
<span class="code-block-extension-codeLine" data-line-num="12"></span>
<span class="code-block-extension-codeLine" data-line-num="13"><span class="hljs-comment">// METADATA_IN_PROPERTY</span></span>
<span class="code-block-extension-codeLine" data-line-num="14"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadata</span>(<span class="hljs-string">'prop:key'</span>, <span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">'prop'</span>));</span>
<span class="code-block-extension-codeLine" data-line-num="15"><span class="hljs-comment">// METADATA_IN_PROPERTY</span></span>
<span class="code-block-extension-codeLine" data-line-num="16"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadata</span>(<span class="hljs-string">'prop:key'</span>, foo, <span class="hljs-string">'prop'</span>));</span>
</code></pre>
<p>看起来我们现在拥有了实现委托的基本能力，但实际上这还不够。所有的元数据都需要我们提前定义好，如果我们希望直接用一些已有的信息作为元数据呢？比如下面这个例子：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="2">  <span class="hljs-meta">@InjectModel</span>()</span>
<span class="code-block-extension-codeLine" data-line-num="3">  <span class="hljs-attr">userModel</span>: <span class="hljs-title class_">UserModel</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="4">}</span>
</code></pre>
<p>我希望将 userModel 属性的类型 UserModel 作为一个元数据信息注入，同时我不会为 <code>@InjectModel()</code> 装饰器提供任何信息，那我们就束手无策了吗？</p>
<p>还记得我们在介绍反射概念时说的，<strong>反射允许程序去检视自身</strong>，而属性类型作为程序的一部分，也应当是能被反射收集的。为了实现这一目的，TypeScript 内的反射元数据中还内置了基于类型的元数据信息，你可以通过 <code>design:type</code>、<code>design:paramtypes</code> 以及 <code>design:returntype</code> 这三个内置的元数据 Key，获取到类与类成员的类型、参数类型、返回值类型：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">import</span> <span class="hljs-string">'reflect-metadata'</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="2"></span>
<span class="code-block-extension-codeLine" data-line-num="3"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Inject</span>(<span class="hljs-params"></span>) {</span>
<span class="code-block-extension-codeLine" data-line-num="4">  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> { }</span>
<span class="code-block-extension-codeLine" data-line-num="5">}</span>
<span class="code-block-extension-codeLine" data-line-num="6"></span>
<span class="code-block-extension-codeLine" data-line-num="7"><span class="hljs-meta">@Inject</span>()</span>
<span class="code-block-extension-codeLine" data-line-num="8"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="9"></span>
<span class="code-block-extension-codeLine" data-line-num="10">  <span class="hljs-meta">@Inject</span>()</span>
<span class="code-block-extension-codeLine" data-line-num="11">  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="12"></span>
<span class="code-block-extension-codeLine" data-line-num="13">  <span class="hljs-meta">@Inject</span>()</span>
<span class="code-block-extension-codeLine" data-line-num="14">  <span class="hljs-title function_">add</span>(<span class="hljs-attr">source</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">input</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="15">    <span class="hljs-keyword">return</span> source + input;</span>
<span class="code-block-extension-codeLine" data-line-num="16">  }</span>
<span class="code-block-extension-codeLine" data-line-num="17">}</span>
<span class="code-block-extension-codeLine" data-line-num="18"></span>
<span class="code-block-extension-codeLine" data-line-num="19"><span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>();</span>
<span class="code-block-extension-codeLine" data-line-num="20"></span>
<span class="code-block-extension-codeLine" data-line-num="21"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadata</span>(<span class="hljs-string">'design:type'</span>, foo, <span class="hljs-string">'name'</span>)); <span class="hljs-comment">// [Function String]</span></span>
<span class="code-block-extension-codeLine" data-line-num="22"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadata</span>(<span class="hljs-string">'design:type'</span>, foo, <span class="hljs-string">'add'</span>)); <span class="hljs-comment">// [Function Function]</span></span>
<span class="code-block-extension-codeLine" data-line-num="23"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadata</span>(<span class="hljs-string">'design:paramtypes'</span>, foo, <span class="hljs-string">'add'</span>)); <span class="hljs-comment">// [[Function Number], [Function Number]]</span></span>
<span class="code-block-extension-codeLine" data-line-num="24"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadata</span>(<span class="hljs-string">'design:returntype'</span>, foo, <span class="hljs-string">'add'</span>)); <span class="hljs-comment">// [Function Number]</span></span>
</code></pre>
<p>实际上，这些内置的元数据信息是由 TypeScript 在编译时提供的。我们来看一个简单点的例子与它的编译结果：</p>
<p>需要注意的是，这些类型信息是来自于运行时，而非我们的类型标注。同时这些内置元数据取出的值是装箱类型对象，如 String、Number 等。</p>
<p>TypeScript 为其进行了额外的支持，然后我们才可以获取到类型标注所对应的元数据，如：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">import</span> <span class="hljs-string">'reflect-metadata'</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="2"></span>
<span class="code-block-extension-codeLine" data-line-num="3"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Inject</span>(<span class="hljs-params"></span>) {</span>
<span class="code-block-extension-codeLine" data-line-num="4">  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> { }</span>
<span class="code-block-extension-codeLine" data-line-num="5">}</span>
<span class="code-block-extension-codeLine" data-line-num="6"></span>
<span class="code-block-extension-codeLine" data-line-num="7"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {}</span>
<span class="code-block-extension-codeLine" data-line-num="8"></span>
<span class="code-block-extension-codeLine" data-line-num="9"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="10">  <span class="hljs-meta">@Inject</span>()</span>
<span class="code-block-extension-codeLine" data-line-num="11">  prop!: <span class="hljs-title class_">Foo</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="12">}</span>
</code></pre>
<p>这段代码的编译结果大概长这样：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">javascript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-javascript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">var</span> __decorate = <span class="hljs-comment">/* ... */</span></span>
<span class="code-block-extension-codeLine" data-line-num="2"></span>
<span class="code-block-extension-codeLine" data-line-num="3"><span class="hljs-keyword">var</span> __metadata = (<span class="hljs-variable language_">this</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">__metadata</span>) || <span class="hljs-keyword">function</span> (<span class="hljs-params">k, v</span>) {</span>
<span class="code-block-extension-codeLine" data-line-num="4">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Reflect</span> === <span class="hljs-string">"object"</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-property">metadata</span> === <span class="hljs-string">"function"</span>) <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">metadata</span>(k, v);</span>
<span class="code-block-extension-codeLine" data-line-num="5">};</span>
<span class="code-block-extension-codeLine" data-line-num="6"></span>
<span class="code-block-extension-codeLine" data-line-num="7"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-built_in">exports</span>, <span class="hljs-string">"__esModule"</span>, { <span class="hljs-attr">value</span>: <span class="hljs-literal">true</span> });</span>
<span class="code-block-extension-codeLine" data-line-num="8"><span class="hljs-built_in">require</span>(<span class="hljs-string">"reflect-metadata"</span>);</span>
<span class="code-block-extension-codeLine" data-line-num="9"></span>
<span class="code-block-extension-codeLine" data-line-num="10"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Inject</span>(<span class="hljs-params"></span>) {</span>
<span class="code-block-extension-codeLine" data-line-num="11">    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> { };</span>
<span class="code-block-extension-codeLine" data-line-num="12">}</span>
<span class="code-block-extension-codeLine" data-line-num="13"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="14">}</span>
<span class="code-block-extension-codeLine" data-line-num="15"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="16">}</span>
<span class="code-block-extension-codeLine" data-line-num="17"><span class="hljs-title function_">__decorate</span>([</span>
<span class="code-block-extension-codeLine" data-line-num="18">    <span class="hljs-title class_">Inject</span>(),</span>
<span class="code-block-extension-codeLine" data-line-num="19">    <span class="hljs-title function_">__metadata</span>(<span class="hljs-string">"design:type"</span>, <span class="hljs-title class_">Foo</span>)</span>
<span class="code-block-extension-codeLine" data-line-num="20">], <span class="hljs-title class_">Bar</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">"prop"</span>, <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>);</span>
<span class="code-block-extension-codeLine" data-line-num="21"></span>
</code></pre>
<p>可以看到，<code>design:type</code> 这个元数据实际上是通过 <code>__metadata("design:type", Foo)</code> 这段调用注入的。其实这也是为什么我们需要启用 <code>emitDecoratorMetadata</code> 配置的原因之一，比如我们关掉这个配置再编译一遍：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">var</span> __decorate = <span class="hljs-comment">/* ... */</span></span>
<span class="code-block-extension-codeLine" data-line-num="2"></span>
<span class="code-block-extension-codeLine" data-line-num="3"><span class="hljs-keyword">var</span> __metadata = (<span class="hljs-variable language_">this</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">__metadata</span>) || <span class="hljs-keyword">function</span> (<span class="hljs-params">k, v</span>) {</span>
<span class="code-block-extension-codeLine" data-line-num="4">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Reflect</span> === <span class="hljs-string">"object"</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-property">metadata</span> === <span class="hljs-string">"function"</span>) <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">metadata</span>(k, v);</span>
<span class="code-block-extension-codeLine" data-line-num="5">};</span>
<span class="code-block-extension-codeLine" data-line-num="6"></span>
<span class="code-block-extension-codeLine" data-line-num="7"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-built_in">exports</span>, <span class="hljs-string">"__esModule"</span>, { <span class="hljs-attr">value</span>: <span class="hljs-literal">true</span> });</span>
<span class="code-block-extension-codeLine" data-line-num="8"><span class="hljs-built_in">require</span>(<span class="hljs-string">"reflect-metadata"</span>);</span>
<span class="code-block-extension-codeLine" data-line-num="9"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Inject</span>(<span class="hljs-params"></span>) {</span>
<span class="code-block-extension-codeLine" data-line-num="10">    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> { };</span>
<span class="code-block-extension-codeLine" data-line-num="11">}</span>
<span class="code-block-extension-codeLine" data-line-num="12"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="13">}</span>
<span class="code-block-extension-codeLine" data-line-num="14"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="15">}</span>
<span class="code-block-extension-codeLine" data-line-num="16"><span class="hljs-title function_">__decorate</span>([</span>
<span class="code-block-extension-codeLine" data-line-num="17">    <span class="hljs-title class_">Inject</span>()</span>
<span class="code-block-extension-codeLine" data-line-num="18">], <span class="hljs-title class_">Bar</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">"prop"</span>, <span class="hljs-built_in">void</span> <span class="hljs-number">0</span>);</span>
</code></pre>
<p>这个对比是不是就一目了然了？</p>
<p>有了装饰器、反射元数据以及内置的基于类型的元数据信息，我们就可以实现“委托”的能力了。以看似平平无奇的属性装饰器为例，我们使用元数据来实现基于装饰器的属性校验。</p>
<p>在这个例子里，我们会实现两种校验逻辑，对必填属性（Required）与属性类型的校验（String / Number / Boolean），其基本使用方式如下：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="2"> &nbsp;<span class="hljs-meta">@Required</span>()</span>
<span class="code-block-extension-codeLine" data-line-num="3"> &nbsp;name!: <span class="hljs-built_in">string</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="4"></span>
<span class="code-block-extension-codeLine" data-line-num="5"> &nbsp;<span class="hljs-meta">@ValueType</span>(<span class="hljs-title class_">TypeValidation</span>.<span class="hljs-property">Number</span>)</span>
<span class="code-block-extension-codeLine" data-line-num="6"> &nbsp;age!: <span class="hljs-built_in">number</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="7">}</span>
<span class="code-block-extension-codeLine" data-line-num="8"></span>
<span class="code-block-extension-codeLine" data-line-num="9"><span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();</span>
<span class="code-block-extension-codeLine" data-line-num="10"><span class="hljs-comment">// @ts-expect-error</span></span>
<span class="code-block-extension-codeLine" data-line-num="11">user.<span class="hljs-property">age</span> = <span class="hljs-string">'18'</span>;</span>
</code></pre>
<p>我们会将 user 实例传递给校验方法，在这里应当给出两处错误：</p>
<ul>
<li>没有提供必填属性 name</li>
<li>age 属性的类型不符。</li>
</ul>
<p>如果理解了元数据的作用，那我们的思路就很明确了，装饰器将元数据附加到属性或类上，然后校验方法中遍历属性读取这些元数据，再对比类型是否匹配即可。</p>
<p>首先是 Required ，我们肯定下意识是这么写：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Required</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">PropertyDecorator</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="2"> &nbsp;<span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">target, prop</span>) =&gt;</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="3"> &nbsp; &nbsp;<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineMetadata</span>(<span class="hljs-string">"required"</span>, <span class="hljs-literal">true</span>, target, prop);</span>
<span class="code-block-extension-codeLine" data-line-num="4">  };</span>
<span class="code-block-extension-codeLine" data-line-num="5">}</span>
</code></pre>
<p>也就是在这个属性上定义了一个名为 required 的元数据。但你是否想过，如果实例中根本就没有这个属性呢？就像上面的 user 一样，那这里的元数据不就丢失了？</p>
<p>要解决这一问题，其实只需要将元数据定义在类上即可。我们用一个专门描述必填属性的元数据，存储这个类内部所有的必填属性即可：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">const</span> requiredMetadataKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'requiredKeys'</span>);</span>
<span class="code-block-extension-codeLine" data-line-num="2"></span>
<span class="code-block-extension-codeLine" data-line-num="3"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Required</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">PropertyDecorator</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="4"> &nbsp;<span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">target, prop</span>) =&gt;</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="5"> &nbsp; &nbsp;<span class="hljs-keyword">const</span> <span class="hljs-attr">existRequiredKeys</span>: <span class="hljs-built_in">string</span>[] =</span>
<span class="code-block-extension-codeLine" data-line-num="6"> &nbsp; &nbsp; &nbsp;<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadata</span>(requiredMetadataKey, target) ?? [];</span>
<span class="code-block-extension-codeLine" data-line-num="7"></span>
<span class="code-block-extension-codeLine" data-line-num="8"> &nbsp; &nbsp;<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineMetadata</span>(</span>
<span class="code-block-extension-codeLine" data-line-num="9"> &nbsp; &nbsp; &nbsp;requiredMetadataKey,</span>
<span class="code-block-extension-codeLine" data-line-num="10"> &nbsp; &nbsp;  [...existRequiredKeys, prop],</span>
<span class="code-block-extension-codeLine" data-line-num="11"> &nbsp; &nbsp; &nbsp;target</span>
<span class="code-block-extension-codeLine" data-line-num="12"> &nbsp;  );</span>
<span class="code-block-extension-codeLine" data-line-num="13">  };</span>
<span class="code-block-extension-codeLine" data-line-num="14">}</span>
</code></pre>
<p>而对于属性的校验其实就简单了，由于对类型的校验逻辑可以归到一起，我们就使用<strong>装饰器工厂 + 入参</strong>的形式来注入对应的元数据信息，这次我们只需要在属性层面注入元数据即可：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">TypeValidation</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="2"> &nbsp;<span class="hljs-title class_">String</span> = <span class="hljs-string">'string'</span>,</span>
<span class="code-block-extension-codeLine" data-line-num="3"> &nbsp;<span class="hljs-title class_">Number</span> = <span class="hljs-string">'number'</span>,</span>
<span class="code-block-extension-codeLine" data-line-num="4"> &nbsp;<span class="hljs-title class_">Boolean</span> = <span class="hljs-string">'boolean'</span>,</span>
<span class="code-block-extension-codeLine" data-line-num="5">}</span>
<span class="code-block-extension-codeLine" data-line-num="6"></span>
<span class="code-block-extension-codeLine" data-line-num="7"><span class="hljs-keyword">const</span> validationMetadataKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'expectedType'</span>);</span>
<span class="code-block-extension-codeLine" data-line-num="8"></span>
<span class="code-block-extension-codeLine" data-line-num="9"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ValueType</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>: TypeValidation</span>): <span class="hljs-title class_">PropertyDecorator</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="10"> &nbsp;<span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">target, prop</span>) =&gt;</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="11"> &nbsp; &nbsp;<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineMetadata</span>(validationMetadataKey, <span class="hljs-keyword">type</span>, target, prop);</span>
<span class="code-block-extension-codeLine" data-line-num="12">  };</span>
<span class="code-block-extension-codeLine" data-line-num="13">}</span>
</code></pre>
<p>然后就是校验逻辑了，我们需要一个额外的 validator 方法：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">function</span> <span class="hljs-title function_">validator</span>(<span class="hljs-params">entity: <span class="hljs-built_in">any</span></span>) {}</span>
<span class="code-block-extension-codeLine" data-line-num="2"></span>
<span class="code-block-extension-codeLine" data-line-num="3"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">validator</span>(user));</span>
</code></pre>
<p>如果校验完全通过，那这一方法的返回值则是一个空数组，否则的话内部会存有报错信息。首先是对于必填属性的校验，我们需要取出注册在类上的，描述必填属性的元数据，再检查这些必填属性是否都存在了：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">function</span> <span class="hljs-title function_">validator</span>(<span class="hljs-params">entity: <span class="hljs-built_in">any</span></span>) {</span>
<span class="code-block-extension-codeLine" data-line-num="2"> &nbsp;<span class="hljs-keyword">const</span> clsName = entity.<span class="hljs-property">constructor</span>.<span class="hljs-property">name</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="3"> &nbsp;<span class="hljs-keyword">const</span> <span class="hljs-attr">messages</span>: <span class="hljs-built_in">string</span>[] = [];</span>
<span class="code-block-extension-codeLine" data-line-num="4"> &nbsp;<span class="hljs-comment">// 先检查所有必填属性</span></span>
<span class="code-block-extension-codeLine" data-line-num="5"> &nbsp;<span class="hljs-keyword">const</span> <span class="hljs-attr">requiredKeys</span>: <span class="hljs-built_in">string</span>[] = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadata</span>(</span>
<span class="code-block-extension-codeLine" data-line-num="6"> &nbsp; &nbsp;requiredMetadataKey,</span>
<span class="code-block-extension-codeLine" data-line-num="7"> &nbsp; &nbsp;entity</span>
<span class="code-block-extension-codeLine" data-line-num="8">  );</span>
<span class="code-block-extension-codeLine" data-line-num="9"></span>
<span class="code-block-extension-codeLine" data-line-num="10"> &nbsp;<span class="hljs-comment">// 基于反射拿到所有存在的属性</span></span>
<span class="code-block-extension-codeLine" data-line-num="11"> &nbsp;<span class="hljs-keyword">const</span> existKeys = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(entity);</span>
<span class="code-block-extension-codeLine" data-line-num="12"></span>
<span class="code-block-extension-codeLine" data-line-num="13"> &nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> requiredKeys) {</span>
<span class="code-block-extension-codeLine" data-line-num="14"> &nbsp; &nbsp;<span class="hljs-keyword">if</span> (!existKeys.<span class="hljs-title function_">includes</span>(key)) {</span>
<span class="code-block-extension-codeLine" data-line-num="15"> &nbsp; &nbsp; &nbsp;messages.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">${clsName}</span>.<span class="hljs-subst">${key}</span> should be required.`</span>);</span>
<span class="code-block-extension-codeLine" data-line-num="16"> &nbsp; &nbsp; &nbsp;<span class="hljs-comment">// throw new Error(`${key} is required!`);</span></span>
<span class="code-block-extension-codeLine" data-line-num="17"> &nbsp;  }</span>
<span class="code-block-extension-codeLine" data-line-num="18">  }</span>
<span class="code-block-extension-codeLine" data-line-num="19"></span>
<span class="code-block-extension-codeLine" data-line-num="20"> &nbsp;<span class="hljs-keyword">return</span> messages;</span>
<span class="code-block-extension-codeLine" data-line-num="21">}</span>
</code></pre>
<p>然后是对属性类型的校验，我们的 TypeValidation 枚举中，枚举值就是 <code>typeof</code> 的返回值，因此这里直接使用即可：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">function</span> <span class="hljs-title function_">validator</span>(<span class="hljs-params">entity: <span class="hljs-built_in">any</span></span>) {</span>
<span class="code-block-extension-codeLine" data-line-num="2"> &nbsp;<span class="hljs-comment">// ...</span></span>
<span class="code-block-extension-codeLine" data-line-num="3"> &nbsp;<span class="hljs-comment">// 接着基于定义在属性上的元数据校验属性类型</span></span>
<span class="code-block-extension-codeLine" data-line-num="4"> &nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> existKeys) {</span>
<span class="code-block-extension-codeLine" data-line-num="5"> &nbsp; &nbsp;<span class="hljs-keyword">const</span> <span class="hljs-attr">expectedType</span>: <span class="hljs-built_in">string</span> = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadata</span>(</span>
<span class="code-block-extension-codeLine" data-line-num="6"> &nbsp; &nbsp; &nbsp;validationMetadataKey,</span>
<span class="code-block-extension-codeLine" data-line-num="7"> &nbsp; &nbsp; &nbsp;entity,</span>
<span class="code-block-extension-codeLine" data-line-num="8"> &nbsp; &nbsp; &nbsp;key</span>
<span class="code-block-extension-codeLine" data-line-num="9"> &nbsp;  );</span>
<span class="code-block-extension-codeLine" data-line-num="10"></span>
<span class="code-block-extension-codeLine" data-line-num="11"> &nbsp; &nbsp;<span class="hljs-keyword">if</span> (!expectedType) <span class="hljs-keyword">continue</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="12"></span>
<span class="code-block-extension-codeLine" data-line-num="13"> &nbsp; &nbsp;<span class="hljs-comment">// 枚举也是对象，因此 Object.values 同样可以生效（只不过也会包括键名）</span></span>
<span class="code-block-extension-codeLine" data-line-num="14"> &nbsp; &nbsp;<span class="hljs-comment">// @ts-expect-error</span></span>
<span class="code-block-extension-codeLine" data-line-num="15"> &nbsp; &nbsp;<span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(<span class="hljs-title class_">TypeValidation</span>).<span class="hljs-title function_">includes</span>(expectedType)) {</span>
<span class="code-block-extension-codeLine" data-line-num="16"> &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">const</span> actualType = <span class="hljs-keyword">typeof</span> entity[key];</span>
<span class="code-block-extension-codeLine" data-line-num="17"> &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">if</span> (actualType !== expectedType) {</span>
<span class="code-block-extension-codeLine" data-line-num="18"> &nbsp; &nbsp; &nbsp; &nbsp;messages.<span class="hljs-title function_">push</span>(</span>
<span class="code-block-extension-codeLine" data-line-num="19"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-string">`expect <span class="hljs-subst">${entity.constructor.name}</span>.<span class="hljs-subst">${<span class="hljs-built_in">String</span>(</span></span></span>
<span class="code-block-extension-codeLine" data-line-num="20"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;key</span>
<span class="code-block-extension-codeLine" data-line-num="21"> &nbsp; &nbsp; &nbsp; &nbsp;  )} to be <span class="hljs-subst">${expectedType}</span>, but got <span class="hljs-subst">${actualType}</span>.`</span>
<span class="code-block-extension-codeLine" data-line-num="22"> &nbsp; &nbsp; &nbsp;  );</span>
<span class="code-block-extension-codeLine" data-line-num="23"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-comment">// throw new Error(`${String(key)} is not ${expectedType}!`);</span></span>
<span class="code-block-extension-codeLine" data-line-num="24"> &nbsp; &nbsp;  }</span>
<span class="code-block-extension-codeLine" data-line-num="25"> &nbsp;  }</span>
<span class="code-block-extension-codeLine" data-line-num="26">  }</span>
<span class="code-block-extension-codeLine" data-line-num="27"> &nbsp;<span class="hljs-keyword">return</span> messages;</span>
<span class="code-block-extension-codeLine" data-line-num="28">}</span>
</code></pre>
<p>最终的输出会是这样的：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">css</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-css code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-selector-attr">[ &nbsp;<span class="hljs-string">'User.name should be required.'</span>, &nbsp;<span class="hljs-string">'expect User.age to be number, but got string.'</span>]</span></span>
</code></pre>
<p>除了这两种校验，你也可以通过元数据的帮助来实现更复杂的校验逻辑。如 MinLength、MaxLength、Min、Max 甚至 Email、IP 这样，对属性值内容的校验。思路仍然还是那么简单明了：<strong>注册元数据，消费元数据</strong>。</p>
<blockquote>
<p>那么元数据又存储在哪里？提案中专门说明了这一点，为类或类属性添加了元数据后，构造函数（或是构造函数的原型，根据静态成员还是实例成员决定）会具有 <code>[[Metadata]]</code> 属性，该属性内部包含一个 Map 结构，键为属性键，值为元数据键值对。也就是说，<strong>静态成员的元数据信息存储于构造函数</strong>，而<strong>实例成员的元数据信息存储于构造函数的原型上</strong>。</p>
</blockquote>
<h2 data-id="heading-10">总结与预告</h2>
<p>这一节，我们了解了装饰器的基本概念，包括 TypeScript 中的五种装饰器，以及这些装饰器的入参、使用场景、执行顺序等等。另外我们还掌握了反射元数据的使用，目前看起来它好像并没有什么特别之处？那么在下一节，我们就会在反射元数据的基础上，去了解一个新的概念：控制反转。</p>
<h2 data-id="heading-11">扩展阅读</h2>
<h3 data-id="heading-12">装饰器的坎坷进历程</h3>
<p>正如我们在开头提到的，装饰器从被作为一个提案提出开始，很是经历了一番风雨，下面我们就来具体介绍一下它到底都经历了些什么。</p>
<p>首先需要明确的是，目前 JavaScript（ECMAScript）中的装饰器，和我们这节学习的 TypeScript 装饰器基本是两件完全不同的事物。<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftc39%2Fproposal-decorators" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/tc39/proposal-decorators" ref="nofollow noopener noreferrer">装饰器提案</a> 距离最开始提出已经过去了数年，在这期间提案内容，也就是语法、作用与运行时机制等，已经迭代了四个版本。</p>
<p>第四个版本在 2022 年 3 月份的 TC39 会议中终于如愿进入 Stage 3，也就意味着这一版本的实现基本上就是未来最终落地的版本。此前的版本都在 Stage 2 就胎死腹中，而 TypeScript 与 Babel 中的装饰器则是基于第一版的提案实现的，虽然语法都还是 <code>@</code> ，但这两个版本的装饰器实际上差异非常之大。</p>
<blockquote>
<p>如果你有兴趣了解新版装饰器的具体语义，可以阅读我此前发表的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F6PTcjJQTED3WpJH8ToXInw" target="_blank" rel="nofollow noopener noreferrer" title="https://mp.weixin.qq.com/s/6PTcjJQTED3WpJH8ToXInw" ref="nofollow noopener noreferrer">2022 年 3 月 TC39 会议报告</a> 来了解更多。另外，在 ECMAScript 装饰器进入 Stage 4，或已经有可用的编译支持（Babel / TypeScript ）后，我也会更新关于新版装饰器的使用说明。</p>
</blockquote>
<p>通常来说， TypeScript 只会对已经到达 Stage 3 的提案进行提前的支持，如可选链、空值合并、逻辑赋值等。当 TypeScript 最初引入装饰器时大概是在 2015 年，此时装饰器提案位于 Stage 1 阶段。</p>
<p>促使 TS 提前引入的一个重要原因是，当时存在一门 TS 的超集语言（也就是 JS 的超集的超集？）  <a href="https://link.juejin.cn?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FAtScript" target="_blank" rel="nofollow noopener noreferrer" title="https://en.wikipedia.org/wiki/AtScript" ref="nofollow noopener noreferrer">AtScript</a>，它在 TS 的基础上去支持了装饰器语法，来供 Angular 框架使用。TS 团队与 Angular 团队在某种契机下达成一致，决定将装饰器以及相关的注解能力直接引入 TypeScript 中，而 Angular 团队不再维护 AtScript ，这实际上避免了未来可能出现的竞争与社区生态分裂问题。</p>
<p>虽然这两个版本的装饰器确实差异很大，但你其实无需担心出现未来需要面对断崖式的更新，目前新版装饰器的能力基本上能完全覆盖旧版所能提供的能力，因此升级成本对于用户或者框架开发者来说都不会太高。而如果还想继续使用旧版装饰器怎么办？我猜 TypeScript 会通过引入一个新的 Compiler Option 来控制实际表现与编译产物。</p>
<h3 data-id="heading-13">Reflect.decorate</h3>
<p>如果你去观察了装饰器的编译代码，会发现 <code>__decorate</code> 方法中有一段代码是检查 <code>Reflect.decorate</code> 方法是否存在。这一方法其实也来自于 Reflect Metadata，见 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Frbuckton%2Freflect-metadata%2Fblob%2Fmaster%2FReflect.ts%23L115" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/rbuckton/reflect-metadata/blob/master/Reflect.ts#L115" ref="nofollow noopener noreferrer">L115</a>。这一方法的作用就是，通过反射的方式来进行装饰，如：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {}</span>
<span class="code-block-extension-codeLine" data-line-num="2"></span>
<span class="code-block-extension-codeLine" data-line-num="3"><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">decorate</span>([<span class="hljs-comment">/** ...一组装饰器 */</span>], <span class="hljs-title class_">Foo</span>)</span>
</code></pre>
<p>这也就意味着，你甚至可以<strong>在方法内部去装饰某一个类或其成</strong>员，而不是仅仅只能依赖需要提前定义好的装饰器。</p></div>
