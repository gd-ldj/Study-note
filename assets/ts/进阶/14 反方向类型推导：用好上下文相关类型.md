<div class="markdown-body"><p>TypeScript 拥有非常强大的类型推导能力，不仅会在你声明一个变量时自动推导其类型，也会基于函数内部逻辑自动推导其返回值类型，还会在你使用 typeof 、instanceof 等工具时自动地收窄类型（可辨识联合类型）等等。这些类型推导其实有一个共同点：<strong>它们的推导依赖开发者的输入</strong>，比如变量声明、函数逻辑、类型保护都需要开发者的输入。实际上， TypeScript 中还存在着另一种类型推导，它默默无闻却又无处不在，它就是这一节的主角：<strong>上下文类型（Contextual Typing）</strong>。</p>
<p>这一节的内容比较短，因为上下文类型并不是一个多复杂、多庞大的概念（不涉及实现源码的情况下），但在实际开发中，我们经常会受益于上下文类型的推导能力，只不过你可能不知道背后是它得作用。学完这一节，以后感受到上下文类型存在时，你就可以在心里默默地说一句：“谢谢你，上下文类型”。</p>
<blockquote>
<p>本节代码见：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Flinbudu599%2FTypeScript-Tiny-Book%2Ftree%2Fmain%2Fpackages%2F11-contextual-typing" target="_blank" rel="nofollow noopener noreferrer" title="https://github.com/linbudu599/TypeScript-Tiny-Book/tree/main/packages/11-contextual-typing" ref="nofollow noopener noreferrer">Contextual Typings</a></p>
</blockquote>
<h2 data-id="heading-0">无处不在的上下文类型</h2>
<p>首先举一个最常见的例子：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-variable language_">window</span>.<span class="hljs-property">onerror</span> = <span class="hljs-function">(<span class="hljs-params">event, source, line, col, err</span>) =&gt;</span> {};</span>
</code></pre>
<p>在这个例子里，虽然我们并没有为 onerror 的各个参数声明类型，但是它们也已经获得了正确的类型。</p>
<p>当然你肯定能猜到，这是因为 onerror 的类型声明已经内置了：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Handler</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="2">  <span class="hljs-comment">// 简化</span></span>
<span class="code-block-extension-codeLine" data-line-num="3">  <span class="hljs-attr">onerror</span>: <span class="hljs-title class_">OnErrorEventHandlerNonNull</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="4">}</span>
<span class="code-block-extension-codeLine" data-line-num="5"></span>
<span class="code-block-extension-codeLine" data-line-num="6"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">OnErrorEventHandlerNonNull</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="7">    (<span class="hljs-attr">event</span>: <span class="hljs-title class_">Event</span> | <span class="hljs-built_in">string</span>, source?: <span class="hljs-built_in">string</span>, lineno?: <span class="hljs-built_in">number</span>, colno?: <span class="hljs-built_in">number</span>, error?: <span class="hljs-title class_">Error</span>): <span class="hljs-built_in">any</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="8">}</span>
</code></pre>
<p>我们自己实现一个函数签名，其实也是一样的效果：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">type</span> <span class="hljs-title class_">CustomHandler</span> = <span class="hljs-function">(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">boolean</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="2"></span>
<span class="code-block-extension-codeLine" data-line-num="3"><span class="hljs-comment">// 也推导出了参数类型</span></span>
<span class="code-block-extension-codeLine" data-line-num="4"><span class="hljs-keyword">const</span> <span class="hljs-attr">handler</span>: <span class="hljs-title class_">CustomHandler</span> = <span class="hljs-function">(<span class="hljs-params">arg1, arg2</span>) =&gt;</span> <span class="hljs-literal">true</span>;</span>
</code></pre>
<p>除了参数类型，返回值类型同样会纳入管控：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">struct</span>: {</span>
<span class="code-block-extension-codeLine" data-line-num="2">  <span class="hljs-attr">handler</span>: <span class="hljs-title class_">CustomHandler</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="3">};</span>
<span class="code-block-extension-codeLine" data-line-num="4"><span class="hljs-comment">// 不能将类型“void”分配给类型“boolean”。</span></span>
<span class="code-block-extension-codeLine" data-line-num="5">struct.<span class="hljs-property">handler</span> = <span class="hljs-function">(<span class="hljs-params">name, age</span>) =&gt;</span> {};</span>
</code></pre>
<p>当然，不仅是箭头函数，函数表达式也是一样的效果，这里就不做展开了。</p>
<p>在这里，参数的类型基于其上下文类型中的参数类型位置来进行匹配，arg1 对应到 name ，所以是 string 类型，arg2 对应到 age，所以是 number 类型。这就是上下文类型的核心理念：<strong>基于位置的类型推导</strong>。同时，相对于我们上面提到的基于开发者输入进行的类型推导，上下文类型更像是<strong>反方向的类型推导</strong>，也就是<strong>基于已定义的类型来规范开发者的使用</strong>。</p>
<p>在上下文类型中，我们实现的表达式可以只使用更少的参数，而不能使用更多，这还是因为上下文类型基于位置的匹配，一旦参数个数超过定义的数量，那就没法进行匹配了。</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-comment">// 正常</span></span>
<span class="code-block-extension-codeLine" data-line-num="2"><span class="hljs-variable language_">window</span>.<span class="hljs-property">onerror</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {};</span>
<span class="code-block-extension-codeLine" data-line-num="3"><span class="hljs-comment">// 报错</span></span>
<span class="code-block-extension-codeLine" data-line-num="4"><span class="hljs-variable language_">window</span>.<span class="hljs-property">onerror</span> = <span class="hljs-function">(<span class="hljs-params">event, source, line, col, err, extra</span>) =&gt;</span> {};</span>
</code></pre>
<p>上下文类型也可以进行”嵌套“情况下的类型推导，如以下这个例子：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> <span class="hljs-attr">func</span>: <span class="hljs-function">(<span class="hljs-params">raw: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">input: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">any</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="2"></span>
<span class="code-block-extension-codeLine" data-line-num="3"><span class="hljs-comment">// raw → number</span></span>
<span class="code-block-extension-codeLine" data-line-num="4">func = <span class="hljs-function">(<span class="hljs-params">raw</span>) =&gt;</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="5">  <span class="hljs-comment">// input → string</span></span>
<span class="code-block-extension-codeLine" data-line-num="6">  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">input</span>) =&gt;</span> {};</span>
<span class="code-block-extension-codeLine" data-line-num="7">};</span>
</code></pre>
<p>在某些情况下，上下文类型的推导能力也会失效，比如这里我们使用一个由函数类型组成的联合类型：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="2">  foo!: <span class="hljs-built_in">number</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="3">}</span>
<span class="code-block-extension-codeLine" data-line-num="4"></span>
<span class="code-block-extension-codeLine" data-line-num="5"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Foo</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="6">  bar!: <span class="hljs-built_in">number</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="7">}</span>
<span class="code-block-extension-codeLine" data-line-num="8"></span>
<span class="code-block-extension-codeLine" data-line-num="9"><span class="hljs-keyword">let</span> <span class="hljs-attr">f1</span>: { (<span class="hljs-attr">input</span>: <span class="hljs-title class_">Foo</span>): <span class="hljs-built_in">void</span> } | { (<span class="hljs-attr">input</span>: <span class="hljs-title class_">Bar</span>): <span class="hljs-built_in">void</span> };</span>
<span class="code-block-extension-codeLine" data-line-num="10"><span class="hljs-comment">// 参数“input”隐式具有“any”类型。</span></span>
<span class="code-block-extension-codeLine" data-line-num="11">f1 = <span class="hljs-function">(<span class="hljs-params">input</span>) =&gt;</span> {};</span>
</code></pre>
<p>我们预期的结果是 input 被推导为 <code>Foo | Bar</code> 类型，也就是所有符合结构的函数类型的参数，但却失败了。这是因为 TypeScript 中的上下文类型目前暂时不支持这一判断方式（而不是这不属于上下文类型的能力范畴）。</p>
<p>你可以直接使用一个联合类型参数的函数签名：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">let</span> <span class="hljs-attr">f2</span>: { (<span class="hljs-attr">input</span>: <span class="hljs-title class_">Foo</span> | <span class="hljs-title class_">Bar</span>): <span class="hljs-built_in">void</span> };</span>
<span class="code-block-extension-codeLine" data-line-num="2"><span class="hljs-comment">// Foo | Bar</span></span>
<span class="code-block-extension-codeLine" data-line-num="3">f2 = <span class="hljs-function">(<span class="hljs-params">input</span>) =&gt;</span> {};</span>
</code></pre>
<p>而如果联合类型中将这两个类型再嵌套一层，此时上下文类型反而正常了：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">let</span> <span class="hljs-attr">f3</span>:</span>
<span class="code-block-extension-codeLine" data-line-num="2">  | { (<span class="hljs-attr">raw</span>: <span class="hljs-built_in">number</span>): <span class="hljs-function">(<span class="hljs-params">input: Foo</span>) =&gt;</span> <span class="hljs-built_in">void</span> }</span>
<span class="code-block-extension-codeLine" data-line-num="3">  | { (<span class="hljs-attr">raw</span>: <span class="hljs-built_in">number</span>): <span class="hljs-function">(<span class="hljs-params">input: Bar</span>) =&gt;</span> <span class="hljs-built_in">void</span> };</span>
<span class="code-block-extension-codeLine" data-line-num="4"></span>
<span class="code-block-extension-codeLine" data-line-num="5"><span class="hljs-comment">// raw → number</span></span>
<span class="code-block-extension-codeLine" data-line-num="6">f3 = <span class="hljs-function">(<span class="hljs-params">raw</span>) =&gt;</span> {</span>
<span class="code-block-extension-codeLine" data-line-num="7">  <span class="hljs-comment">// input → Bar</span></span>
<span class="code-block-extension-codeLine" data-line-num="8">  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">input</span>) =&gt;</span> {};</span>
<span class="code-block-extension-codeLine" data-line-num="9">};</span>
</code></pre>
<p>这里被推导为 Bar 的原因，其实还和我们此前了解的协变、逆变有关。任何接收 Foo 类型参数的地方，都可以接收一个 Bar 类型参数，因此推导到 Bar 类型要更加安全。</p>
<h2 data-id="heading-1">void 返回值类型下的特殊情况</h2>
<p>我们前面说到，上下文类型同样会推导并约束函数的返回值类型，但存在这么个特殊的情况，当内置函数类型的返回值类型为 void 时：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">type</span> <span class="hljs-title class_">CustomHandler</span> = <span class="hljs-function">(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="2"></span>
<span class="code-block-extension-codeLine" data-line-num="3"><span class="hljs-keyword">const</span> <span class="hljs-attr">handler1</span>: <span class="hljs-title class_">CustomHandler</span> = <span class="hljs-function">(<span class="hljs-params">name, age</span>) =&gt;</span> <span class="hljs-literal">true</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="4"><span class="hljs-keyword">const</span> <span class="hljs-attr">handler2</span>: <span class="hljs-title class_">CustomHandler</span> = <span class="hljs-function">(<span class="hljs-params">name, age</span>) =&gt;</span> <span class="hljs-string">'linbudu'</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="5"><span class="hljs-keyword">const</span> <span class="hljs-attr">handler3</span>: <span class="hljs-title class_">CustomHandler</span> = <span class="hljs-function">(<span class="hljs-params">name, age</span>) =&gt;</span> <span class="hljs-literal">null</span>;</span>
<span class="code-block-extension-codeLine" data-line-num="6"><span class="hljs-keyword">const</span> <span class="hljs-attr">handler4</span>: <span class="hljs-title class_">CustomHandler</span> = <span class="hljs-function">(<span class="hljs-params">name, age</span>) =&gt;</span> <span class="hljs-literal">undefined</span>;</span>
</code></pre>
<p>你会发现这个时候，我们的函数实现返回值类型变成了五花八门的样子，而且还都不会报错？同样的，这也是一条世界底层的规则，<strong>上下文类型对于 void 返回值类型的函数，并不会真的要求它啥都不能返回</strong>。然而，虽然这些函数实现可以返回任意类型的值，但<strong>对于调用结果的类型，仍然是 void</strong>：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">const</span> result1 = <span class="hljs-title function_">handler1</span>(<span class="hljs-string">'linbudu'</span>, <span class="hljs-number">599</span>); <span class="hljs-comment">// void</span></span>
<span class="code-block-extension-codeLine" data-line-num="2"><span class="hljs-keyword">const</span> result2 = <span class="hljs-title function_">handler2</span>(<span class="hljs-string">'linbudu'</span>, <span class="hljs-number">599</span>); <span class="hljs-comment">// void</span></span>
<span class="code-block-extension-codeLine" data-line-num="3"><span class="hljs-keyword">const</span> result3 = <span class="hljs-title function_">handler3</span>(<span class="hljs-string">'linbudu'</span>, <span class="hljs-number">599</span>); <span class="hljs-comment">// void</span></span>
<span class="code-block-extension-codeLine" data-line-num="4"><span class="hljs-keyword">const</span> result4 = <span class="hljs-title function_">handler4</span>(<span class="hljs-string">'linbudu'</span>, <span class="hljs-number">599</span>); <span class="hljs-comment">// void</span></span>
</code></pre>
<p>看起来这是一种很奇怪的、错误的行为，但实际上，我们日常开发中的很多代码都需要这一“不正确的”行为才不会报错，比如以下这个例子：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">const</span> <span class="hljs-attr">arr</span>: <span class="hljs-built_in">number</span>[] = [];</span>
<span class="code-block-extension-codeLine" data-line-num="2"><span class="hljs-keyword">const</span> <span class="hljs-attr">list</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];</span>
<span class="code-block-extension-codeLine" data-line-num="3"></span>
<span class="code-block-extension-codeLine" data-line-num="4">list.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> arr.<span class="hljs-title function_">push</span>(item));</span>
</code></pre>
<p>这是我们常用的简写方式，然而，push 方法的返回值是一个 number 类型（push 后数组的长度），而 forEach 的上下文类型声明中要求返回值是 void 类型。如果此时 void 类型真的不允许任何返回值，那这里我们就需要多套一个代码块才能确保类型符合了。</p>
<p>但这真的是有必要的吗？对于一个 void 类型的函数，我们真的会去消费它的返回值吗？既然不会，那么它想返回什么，全凭它乐意就好了。我们还可以用另一种方式来描述这个概念：你可以<strong>将返回值非 void 类型的函数（<code>() =&gt; list.push()</code>）作为返回值类型为 void 类型（<code>arr.forEach</code>）的函数类型参数</strong>。</p>
<h2 data-id="heading-2">总结与预告</h2>
<p>在这一节里，我们学习了上下文类型这“另一个方向”的类型推导，了解了它是基于位置进行类型匹配的，以及上下文类型中 void 类型返回值的特殊情况。</p>
<p>这一节比较轻松对吧？那在下一节，我们会学习一个稍微复杂点的概念：函数类型兼容性比较，以及其中的<strong>协变</strong>与<strong>逆变</strong>概念。我们在前面类型层级一节中，并没有提及函数类型地比较，这也是因为其中的概念相对复杂，需要更多的前置知识与更多的消化过程，因此我单独准备了一节内容。</p>
<h2 data-id="heading-3">扩展阅读</h2>
<h3 data-id="heading-4">将更少参数的函数赋值给具有更多参数的函数类型</h3>
<p>在上面的例子中，我们看到了这么一段代码：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">const</span> <span class="hljs-attr">arr</span>: <span class="hljs-built_in">number</span>[] = [];</span>
<span class="code-block-extension-codeLine" data-line-num="2"><span class="hljs-keyword">const</span> <span class="hljs-attr">list</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];</span>
<span class="code-block-extension-codeLine" data-line-num="3"></span>
<span class="code-block-extension-codeLine" data-line-num="4">list.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> arr.<span class="hljs-title function_">push</span>(item));</span>
</code></pre>
<p>在 forEach 的函数中，我们会消费 list 的每一个成员。但我们有时也会遇到并不实际消费数组成员的情况：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1">list.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">() =&gt;</span> arr.<span class="hljs-title function_">push</span>(otherFactory));</span>
</code></pre>
<p>这个时候，我们实际上就是在<strong>将更少参数的函数赋值给具有更多参数的函数类型</strong>！</p>
<p>再看一个更明显的例子：</p>
<pre><div class="code-block-extension-header" style="background-color: rgb(40, 40, 40);"><div class="code-block-extension-headerLeft"><div class="code-block-extension-foldBtn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16.924 9.617A1 1 0 0 0 16 9H8a1 1 0 0 0-.707 1.707l4 4a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0 .217-1.09z" data-name="Down"></path></svg></div></div><div class="code-block-extension-headerRight"><span class="code-block-extension-lang">typescript</span><div class="code-block-extension-copyCodeBtn">复制代码</div></div></div><code class="hljs language-typescript code-block-extension-codeShowNum"><span class="code-block-extension-codeLine" data-line-num="1"><span class="hljs-keyword">function</span> <span class="hljs-title function_">handler</span>(<span class="hljs-params">arg: <span class="hljs-built_in">string</span></span>) {</span>
<span class="code-block-extension-codeLine" data-line-num="2">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg);</span>
<span class="code-block-extension-codeLine" data-line-num="3">}</span>
<span class="code-block-extension-codeLine" data-line-num="4"></span>
<span class="code-block-extension-codeLine" data-line-num="5"><span class="hljs-keyword">function</span> <span class="hljs-title function_">useHandler</span>(<span class="hljs-params">callback: (arg1: <span class="hljs-built_in">string</span>, arg2: <span class="hljs-built_in">number</span>) =&gt; <span class="hljs-built_in">void</span></span>) {</span>
<span class="code-block-extension-codeLine" data-line-num="6">  <span class="hljs-title function_">callback</span>(<span class="hljs-string">'linbudu'</span>, <span class="hljs-number">599</span>);</span>
<span class="code-block-extension-codeLine" data-line-num="7">}</span>
<span class="code-block-extension-codeLine" data-line-num="8"></span>
<span class="code-block-extension-codeLine" data-line-num="9"><span class="hljs-title function_">useHandler</span>(handler);</span>
</code></pre>
<p>handler 函数的类型签名很明显与 useHandler 函数的 callback 类型签名并不一致，但这里却没有报错。从实用意义的角度来看，如果我们需要类型签名完全一致，那么就需要为 handler 再声明一个额外的对应到 arg2 的参数，然而我们的 handler 代码里实际上并没有去消费第二个参数。这实际上在 JavaScript 中也是我们经常使用的方式：<strong>即使用更少入参的函数来作为一个预期更多入参函数参数的实现</strong>。</p></div>
